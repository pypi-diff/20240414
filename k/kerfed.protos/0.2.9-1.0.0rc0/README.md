# Comparing `tmp/kerfed.protos-0.2.9-py3-none-any.whl.zip` & `tmp/kerfed.protos-1.0.0rc0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,101 +1,11 @@
-Zip file size: 99799 bytes, number of entries: 99
--rw-r--r--  2.0 unx        0 b- defN 23-Nov-17 20:16 kerfed/protos/__init__.py
--rw-r--r--  2.0 unx      295 b- defN 23-Nov-17 20:16 kerfed/protos/api/v1/__init__.py
--rw-r--r--  2.0 unx     2885 b- defN 23-Nov-17 20:17 kerfed/protos/api/v1/cam_pb2.py
--rw-r--r--  2.0 unx     3608 b- defN 23-Nov-17 20:17 kerfed/protos/api/v1/cam_pb2.pyi
--rw-r--r--  2.0 unx     2635 b- defN 23-Nov-17 20:17 kerfed/protos/api/v1/cam_pb2_grpc.py
--rw-r--r--  2.0 unx     3363 b- defN 23-Nov-17 20:17 kerfed/protos/api/v1/geometry_pb2.py
--rw-r--r--  2.0 unx     4454 b- defN 23-Nov-17 20:17 kerfed/protos/api/v1/geometry_pb2.pyi
--rw-r--r--  2.0 unx     2843 b- defN 23-Nov-17 20:17 kerfed/protos/api/v1/geometry_pb2_grpc.py
--rw-r--r--  2.0 unx     2606 b- defN 23-Nov-17 20:17 kerfed/protos/api/v1/order_pb2.py
--rw-r--r--  2.0 unx     2792 b- defN 23-Nov-17 20:17 kerfed/protos/api/v1/order_pb2.pyi
--rw-r--r--  2.0 unx     2690 b- defN 23-Nov-17 20:17 kerfed/protos/api/v1/order_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Nov-17 20:16 kerfed/protos/api/v1/py.typed
--rw-r--r--  2.0 unx     8700 b- defN 23-Nov-17 20:16 kerfed/protos/common/v1/__init__.py
--rw-r--r--  2.0 unx     2309 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/address_pb2.py
--rw-r--r--  2.0 unx     3427 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/address_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/address_pb2_grpc.py
--rw-r--r--  2.0 unx     2362 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/brand_pb2.py
--rw-r--r--  2.0 unx     2545 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/brand_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/brand_pb2_grpc.py
--rw-r--r--  2.0 unx     2481 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/combo_pb2.py
--rw-r--r--  2.0 unx     4315 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/combo_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/combo_pb2_grpc.py
--rw-r--r--  2.0 unx     2212 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/config_pb2.py
--rw-r--r--  2.0 unx     2635 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/config_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/config_pb2_grpc.py
--rw-r--r--  2.0 unx     2237 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/cots_pb2.py
--rw-r--r--  2.0 unx     2349 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/cots_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/cots_pb2_grpc.py
--rw-r--r--  2.0 unx     1768 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/discount_pb2.py
--rw-r--r--  2.0 unx     1156 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/discount_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/discount_pb2_grpc.py
--rw-r--r--  2.0 unx     1742 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/error_pb2.py
--rw-r--r--  2.0 unx      937 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/error_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/error_pb2_grpc.py
--rw-r--r--  2.0 unx     7875 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/fab_pb2.py
--rw-r--r--  2.0 unx    19537 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/fab_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/fab_pb2_grpc.py
--rw-r--r--  2.0 unx     1905 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/fileblob_pb2.py
--rw-r--r--  2.0 unx     1745 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/fileblob_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/fileblob_pb2_grpc.py
--rw-r--r--  2.0 unx     3358 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/geometry_pb2.py
--rw-r--r--  2.0 unx     5029 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/geometry_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/geometry_pb2_grpc.py
--rw-r--r--  2.0 unx     2888 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/machine_pb2.py
--rw-r--r--  2.0 unx     5483 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/machine_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/machine_pb2_grpc.py
--rw-r--r--  2.0 unx     7766 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/mill_pb2.py
--rw-r--r--  2.0 unx    20925 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/mill_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/mill_pb2_grpc.py
--rw-r--r--  2.0 unx     2273 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/model_pb2.py
--rw-r--r--  2.0 unx     3997 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/model_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/model_pb2_grpc.py
--rw-r--r--  2.0 unx     1753 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/money_pb2.py
--rw-r--r--  2.0 unx     1231 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/money_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/money_pb2_grpc.py
--rw-r--r--  2.0 unx     1984 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/ndarray_pb2.py
--rw-r--r--  2.0 unx     2362 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/ndarray_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/ndarray_pb2_grpc.py
--rw-r--r--  2.0 unx     3898 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/order_pb2.py
--rw-r--r--  2.0 unx     6737 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/order_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/order_pb2_grpc.py
--rw-r--r--  2.0 unx     2062 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/outcome_pb2.py
--rw-r--r--  2.0 unx     2116 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/outcome_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/outcome_pb2_grpc.py
--rw-r--r--  2.0 unx     4711 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/path_pb2.py
--rw-r--r--  2.0 unx    12523 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/path_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/path_pb2_grpc.py
--rw-r--r--  2.0 unx     4639 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/post_pb2.py
--rw-r--r--  2.0 unx     9564 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/post_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/post_pb2_grpc.py
--rw-r--r--  2.0 unx     5411 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/price_pb2.py
--rw-r--r--  2.0 unx    11808 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/price_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/price_pb2_grpc.py
--rw-r--r--  2.0 unx        0 b- defN 23-Nov-17 20:16 kerfed/protos/common/v1/py.typed
--rw-r--r--  2.0 unx     2468 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/scene_pb2.py
--rw-r--r--  2.0 unx     3496 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/scene_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/scene_pb2_grpc.py
--rw-r--r--  2.0 unx     3015 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/shipping_pb2.py
--rw-r--r--  2.0 unx     4449 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/shipping_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/shipping_pb2_grpc.py
--rw-r--r--  2.0 unx     2754 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/shop_pb2.py
--rw-r--r--  2.0 unx     4419 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/shop_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/shop_pb2_grpc.py
--rw-r--r--  2.0 unx     2872 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/stock_pb2.py
--rw-r--r--  2.0 unx     4058 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/stock_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/stock_pb2_grpc.py
--rw-r--r--  2.0 unx     1774 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/timestamp_pb2.py
--rw-r--r--  2.0 unx     1262 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/timestamp_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/timestamp_pb2_grpc.py
--rw-r--r--  2.0 unx     1847 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/tolerance_pb2.py
--rw-r--r--  2.0 unx     1210 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/tolerance_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/tolerance_pb2_grpc.py
--rw-r--r--  2.0 unx     3501 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/tool_pb2.py
--rw-r--r--  2.0 unx     7560 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/tool_pb2.pyi
--rw-r--r--  2.0 unx      159 b- defN 23-Nov-17 20:17 kerfed/protos/common/v1/tool_pb2_grpc.py
--rw-r--r--  2.0 unx      994 b- defN 23-Nov-17 20:17 kerfed.protos-0.2.9.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Nov-17 20:17 kerfed.protos-0.2.9.dist-info/WHEEL
--rw-r--r--  2.0 unx        7 b- defN 23-Nov-17 20:17 kerfed.protos-0.2.9.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     9313 b- defN 23-Nov-17 20:17 kerfed.protos-0.2.9.dist-info/RECORD
-99 files, 282310 bytes uncompressed, 84725 bytes compressed:  70.0%
+Zip file size: 23517 bytes, number of entries: 9
+-rw-r--r--  2.0 unx        0 b- defN 24-Mar-01 20:48 kerfed/protos/__init__.py
+-rw-r--r--  2.0 unx     8938 b- defN 24-Mar-01 20:49 kerfed/protos/api/v1/__init__.py
+-rw-r--r--  2.0 unx    62171 b- defN 24-Mar-01 20:49 kerfed/protos/common/v1/__init__.py
+-rw-r--r--  2.0 unx     8584 b- defN 24-Mar-01 20:48 kerfed/protos/common/v1/helper.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Mar-01 20:48 kerfed/protos/common/v1/py.typed
+-rw-r--r--  2.0 unx     1571 b- defN 24-Mar-01 20:49 kerfed.protos-1.0.0rc0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Mar-01 20:49 kerfed.protos-1.0.0rc0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        7 b- defN 24-Mar-01 20:49 kerfed.protos-1.0.0rc0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx      770 b- defN 24-Mar-01 20:49 kerfed.protos-1.0.0rc0.dist-info/RECORD
+9 files, 82133 bytes uncompressed, 22169 bytes compressed:  73.0%
```

## zipnote {}

```diff
@@ -1,298 +1,28 @@
 Filename: kerfed/protos/__init__.py
 Comment: 
 
 Filename: kerfed/protos/api/v1/__init__.py
 Comment: 
 
-Filename: kerfed/protos/api/v1/cam_pb2.py
-Comment: 
-
-Filename: kerfed/protos/api/v1/cam_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/api/v1/cam_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/api/v1/geometry_pb2.py
-Comment: 
-
-Filename: kerfed/protos/api/v1/geometry_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/api/v1/geometry_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/api/v1/order_pb2.py
-Comment: 
-
-Filename: kerfed/protos/api/v1/order_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/api/v1/order_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/api/v1/py.typed
-Comment: 
-
 Filename: kerfed/protos/common/v1/__init__.py
 Comment: 
 
-Filename: kerfed/protos/common/v1/address_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/address_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/address_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/brand_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/brand_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/brand_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/combo_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/combo_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/combo_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/config_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/config_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/config_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/cots_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/cots_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/cots_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/discount_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/discount_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/discount_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/error_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/error_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/error_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/fab_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/fab_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/fab_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/fileblob_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/fileblob_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/fileblob_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/geometry_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/geometry_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/geometry_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/machine_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/machine_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/machine_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/mill_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/mill_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/mill_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/model_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/model_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/model_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/money_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/money_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/money_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/ndarray_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/ndarray_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/ndarray_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/order_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/order_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/order_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/outcome_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/outcome_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/outcome_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/path_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/path_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/path_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/post_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/post_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/post_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/price_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/price_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/price_pb2_grpc.py
+Filename: kerfed/protos/common/v1/helper.py
 Comment: 
 
 Filename: kerfed/protos/common/v1/py.typed
 Comment: 
 
-Filename: kerfed/protos/common/v1/scene_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/scene_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/scene_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/shipping_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/shipping_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/shipping_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/shop_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/shop_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/shop_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/stock_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/stock_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/stock_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/timestamp_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/timestamp_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/timestamp_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/tolerance_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/tolerance_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/tolerance_pb2_grpc.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/tool_pb2.py
-Comment: 
-
-Filename: kerfed/protos/common/v1/tool_pb2.pyi
-Comment: 
-
-Filename: kerfed/protos/common/v1/tool_pb2_grpc.py
-Comment: 
-
-Filename: kerfed.protos-0.2.9.dist-info/METADATA
+Filename: kerfed.protos-1.0.0rc0.dist-info/METADATA
 Comment: 
 
-Filename: kerfed.protos-0.2.9.dist-info/WHEEL
+Filename: kerfed.protos-1.0.0rc0.dist-info/WHEEL
 Comment: 
 
-Filename: kerfed.protos-0.2.9.dist-info/top_level.txt
+Filename: kerfed.protos-1.0.0rc0.dist-info/top_level.txt
 Comment: 
 
-Filename: kerfed.protos-0.2.9.dist-info/RECORD
+Filename: kerfed.protos-1.0.0rc0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## kerfed/protos/api/v1/__init__.py

```diff
@@ -1,6 +1,271 @@
-# messages needed to construct an geometry request
-from ...common.v1.fileblob_pb2 import FileBlob
-from .geometry_pb2 import GeometryRequest, GeometryResponse
-from .geometry_pb2_grpc import GeometryServiceStub
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# sources: kerfed/protos/api/v1/cam.proto, kerfed/protos/api/v1/geometry.proto, kerfed/protos/api/v1/order.proto
+# plugin: python-betterproto
+# This file has been @generated
 
-__all__ = ["GeometryRequest", "GeometryResponse", "GeometryServiceStub", "FileBlob"]
+from dataclasses import dataclass
+from typing import (
+    TYPE_CHECKING,
+    Dict,
+    List,
+    Optional,
+)
+
+import betterproto
+import grpclib
+from betterproto.grpc.grpclib_server import ServiceBase
+
+from ...common import v1 as __common_v1__
+
+
+if TYPE_CHECKING:
+    import grpclib.server
+    from betterproto.grpc.grpclib_client import MetadataLike
+    from grpclib.metadata import Deadline
+
+
+@dataclass(eq=False, repr=False)
+class PackRequest(betterproto.Message):
+    """
+    Request flat fabrications to be packed or "nested" onto sheets and produce
+    a machine-ready list of DXF or SVG files.
+    """
+
+    parts: List["__common_v1__.FlatFabrication"] = betterproto.message_field(1)
+    """The flat parts being packed, with `flattened` populated"""
+
+    quantity: List[int] = betterproto.uint32_field(2)
+    """A length-matching"""
+
+    available: List["__common_v1__.Stock"] = betterproto.message_field(3)
+    """
+    Sheet stock with thickness and extents specified. If not passed all parts
+    will be put onto the same sheet.
+    """
+
+    undersize_drill: bool = betterproto.bool_field(4)
+    """Should holes be undersized."""
+
+    format: str = betterproto.string_field(5)
+    """
+    Output file format. Acceptable values are 'svg' and 'dxf' and the default
+    output format is 'dxf'.
+    """
+
+
+@dataclass(eq=False, repr=False)
+class PackResponse(betterproto.Message):
+    packed: List["__common_v1__.FileBlob"] = betterproto.message_field(1)
+    """Packed result as a DXF or SVG."""
+
+    sheets: List["__common_v1__.Stock"] = betterproto.message_field(2)
+    """The sheet size for each packed value."""
+
+
+@dataclass(eq=False, repr=False)
+class GeometryRequest(betterproto.Message):
+    """Request a CAD file to be fully analyzed by the geometry pipeline."""
+
+    source: "__common_v1__.FileBlob" = betterproto.message_field(1)
+    """Raw CAD geometry to be analyzed in a supported format."""
+
+    source_units: str = betterproto.string_field(2)
+    """
+    If the raw file is in a format that does not include unit information (i.e.
+    SVG, DXF, STL, OBJ) specify the file's units through this request. If not
+    passed the pipeline will "guess" the unit system from irregular metadata
+    which may be incorrect.
+    """
+
+    brand: "__common_v1__.Brand" = betterproto.message_field(3)
+    """
+    Apply brand preferences to generated user-facing material i.e. apply a
+    specific logo, display units (mm vs inch), address, etc.
+    """
+
+    settings: "__common_v1__.FabricationSettings" = betterproto.message_field(4)
+    """
+    Edit detailed settings for each manufacturing process such as the maximum
+    spindle speed of milling machines, k-factors for flattening sheet metal,
+    etc.
+    """
+
+    return_previews: bool = betterproto.bool_field(5)
+    """Should the pipeline render rasterized previews of each part?"""
+
+    return_interference: bool = betterproto.bool_field(6)
+    """
+    Should the pipeline calculate part-part interferences and then add
+    additional postprocessing operations where required?
+    """
+
+    return_proprietary: bool = betterproto.bool_field(7)
+    """
+    Enable potentially expensive proprietary formats like SLDPRT, SLDASM, IPT,
+    X_B, etc. Note that these are licensed from third parties and are disabled
+    for most API accounts unless you have had us enable them.
+    """
+
+
+@dataclass(eq=False, repr=False)
+class GeometryResponse(betterproto.Message):
+    outcome: "__common_v1__.Outcome" = betterproto.message_field(1)
+    """
+    Is this geometry analysis complete yet? Clients should check
+    `outome.is_completed` before accessing other properties.
+    """
+
+    analysis: List["__common_v1__.PartFabrication"] = betterproto.message_field(2)
+    """The fabrication analysis."""
+
+    scene: "__common_v1__.Scene" = betterproto.message_field(3)
+    """the loaded file in a neutral format"""
+
+
+@dataclass(eq=False, repr=False)
+class PriceRequest(betterproto.Message):
+    """Generate prices for one or more fully specified parts."""
+
+    spec: List["__common_v1__.LineSpec"] = betterproto.message_field(1)
+    """The fabrication analysis and customer configuration of a part."""
+
+    metadata: "__common_v1__.PriceMetadata" = betterproto.message_field(2)
+    """The pricing data for the shop requesting a price."""
+
+    shipping: "__common_v1__.PostalAddress" = betterproto.message_field(3)
+    """
+    The shipping address of the requested parts to allow the vendor selection
+    algorithm to weight transit distance.
+    """
+
+
+@dataclass(eq=False, repr=False)
+class PriceResponse(betterproto.Message):
+    price: List["__common_v1__.LinePrice"] = betterproto.message_field(1)
+    """Prices for the requested parts."""
+
+
+class CamServiceStub(betterproto.ServiceStub):
+    async def pack(
+        self,
+        pack_request: "PackRequest",
+        *,
+        timeout: Optional[float] = None,
+        deadline: Optional["Deadline"] = None,
+        metadata: Optional["MetadataLike"] = None
+    ) -> "PackResponse":
+        return await self._unary_unary(
+            "/kerfed.protos.api.v1.CAMService/Pack",
+            pack_request,
+            PackResponse,
+            timeout=timeout,
+            deadline=deadline,
+            metadata=metadata,
+        )
+
+
+class GeometryServiceStub(betterproto.ServiceStub):
+    async def geometry(
+        self,
+        geometry_request: "GeometryRequest",
+        *,
+        timeout: Optional[float] = None,
+        deadline: Optional["Deadline"] = None,
+        metadata: Optional["MetadataLike"] = None
+    ) -> "GeometryResponse":
+        return await self._unary_unary(
+            "/kerfed.protos.api.v1.GeometryService/Geometry",
+            geometry_request,
+            GeometryResponse,
+            timeout=timeout,
+            deadline=deadline,
+            metadata=metadata,
+        )
+
+
+class OrderServiceStub(betterproto.ServiceStub):
+    async def price(
+        self,
+        price_request: "PriceRequest",
+        *,
+        timeout: Optional[float] = None,
+        deadline: Optional["Deadline"] = None,
+        metadata: Optional["MetadataLike"] = None
+    ) -> "PriceResponse":
+        return await self._unary_unary(
+            "/kerfed.protos.api.v1.OrderService/Price",
+            price_request,
+            PriceResponse,
+            timeout=timeout,
+            deadline=deadline,
+            metadata=metadata,
+        )
+
+
+class CamServiceBase(ServiceBase):
+
+    async def pack(self, pack_request: "PackRequest") -> "PackResponse":
+        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
+
+    async def __rpc_pack(
+        self, stream: "grpclib.server.Stream[PackRequest, PackResponse]"
+    ) -> None:
+        request = await stream.recv_message()
+        response = await self.pack(request)
+        await stream.send_message(response)
+
+    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
+        return {
+            "/kerfed.protos.api.v1.CAMService/Pack": grpclib.const.Handler(
+                self.__rpc_pack,
+                grpclib.const.Cardinality.UNARY_UNARY,
+                PackRequest,
+                PackResponse,
+            ),
+        }
+
+
+class GeometryServiceBase(ServiceBase):
+
+    async def geometry(self, geometry_request: "GeometryRequest") -> "GeometryResponse":
+        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
+
+    async def __rpc_geometry(
+        self, stream: "grpclib.server.Stream[GeometryRequest, GeometryResponse]"
+    ) -> None:
+        request = await stream.recv_message()
+        response = await self.geometry(request)
+        await stream.send_message(response)
+
+    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
+        return {
+            "/kerfed.protos.api.v1.GeometryService/Geometry": grpclib.const.Handler(
+                self.__rpc_geometry,
+                grpclib.const.Cardinality.UNARY_UNARY,
+                GeometryRequest,
+                GeometryResponse,
+            ),
+        }
+
+
+class OrderServiceBase(ServiceBase):
+
+    async def price(self, price_request: "PriceRequest") -> "PriceResponse":
+        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
+
+    async def __rpc_price(
+        self, stream: "grpclib.server.Stream[PriceRequest, PriceResponse]"
+    ) -> None:
+        request = await stream.recv_message()
+        response = await self.price(request)
+        await stream.send_message(response)
+
+    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
+        return {
+            "/kerfed.protos.api.v1.OrderService/Price": grpclib.const.Handler(
+                self.__rpc_price,
+                grpclib.const.Cardinality.UNARY_UNARY,
+                PriceRequest,
+                PriceResponse,
+            ),
+        }
```

## kerfed/protos/common/v1/__init__.py

```diff
@@ -1,344 +1,1883 @@
-# kerfed.protos.common.v1
-# ------------
-#
-# Helper to keep proto imports in one place.
-
-
-from datetime import datetime
-from typing import Any, List
-
-from .address_pb2 import PostalAddress
-from .combo_pb2 import Combo, ComboDescription, Combos
-from .error_pb2 import Error
-from .fab_pb2 import (
-    AddFabrication,
-    BentFabrication,
-    FlatFabrication,
-    PartFabrication,
-    RollFabrication,
-    TurnFabrication,
-)
-from .fileblob_pb2 import FileBlob
-from .geometry_pb2 import Box, Cylinder, Geometry, Mesh
-from .machine_pb2 import Machine
-from .mill_pb2 import (
-    CutDrill,
-    CutFace,
-    CutMill,
-    Fixture,
-    FixtureStrategy,
-    MillFabrication,
-    MillMachine,
-    MillPreprocess,
-)
-from .model_pb2 import Model
-from .money_pb2 import Money
-from .ndarray_pb2 import NDArray, RigidTransform
-from .order_pb2 import Order
-from .outcome_pb2 import Outcome
-from .price_pb2 import LinePrice, LineSpec, Operation, PriceMetadata
-from .scene_pb2 import GeometrySummary, Scene
-from .shipping_pb2 import ShippingParcel, ShippingRate
-from .brand_pb2 import Brand
-from .stock_pb2 import Stock, StockKind
-
-# standard library
-from .timestamp_pb2 import Timestamp
-from .tool_pb2 import Tool, ToolParameters, ToolShape
-
-try:
-    import numpy as np
-    from numpy.typing import ArrayLike as NumpyLike
-except BaseException:
-    # if numpy isn't installed just run as an any-type
-    from typing import Any as NumpyLike
-
-try:
-    from google.protobuf.json_format import MessageToDict
-except BaseException as E:
-    MessageToDict = E
-
-try:
-    from trimesh import Trimesh
-except BaseException:
-    from typing import Any as Trimesh
-
-
-def sum_money(monies: List[Money]) -> Money:
-    """
-    Sum a list of Money messages.
-
-    Parameters
-    ------------
-    money : List[Money]
-      List of money
-    """
-    # the currency code, i.e. 'usd'
-    currency = monies[0].currency
-    # we can only sum money in the same currency
-    if any(currency != m.currency for m in monies[1:]):
-        raise ValueError("Currencies must match!")
-
-    # sum and return
-    return Money(currency=currency, amount=sum(m.amount for m in monies))
-
-
-def message_to_dict(msg, **kwargs) -> dict:
-    """
-    Convert a protobuf message to dict preserving the field names.
-
-    Parameters
-    -----------
-    msg : protobuf
-      Message to convert to a dict
-
-    Returns
-    -----------
-    converted : dict
-      Message converted to a dict.
-    """
-    return MessageToDict(msg, preserving_proto_field_name=True, **kwargs)
-
-
-def format_money(money: Money) -> str:
-    """
-    Format a protobuf money message.
-
-    Parameters
-    -----------
-    money : kerfed.protos.v1.money_pb2.Money
-      Money object.
-
-    Returns
-    --------
-    formatted : str
-      Formatted string to show a user.
-    """
-    if money.currency.lower() == "usd":
-        return f"${money.amount / 100.0:0.2f}"
-    else:
-        return f"{money.amount / 100} {money.currency.upper()}"
-
-
-def numpy_to_rigid(matrix: NumpyLike) -> RigidTransform:
-    """
-    Convert a (4, 4) rigid homogenous transform
-    to a protobuf RigidTransform object.
-
-
-    Parameters
-    -----------
-    matrix : (4, 4) float
-      Rigid homogeneous transform.
-
-    Returns
-    ------------
-    rigid
-      Rigid transform object.
-    """
-    assert matrix.shape == (4, 4)
-    # strip off the last row which is [0, 0, 0, 1]
-    # and make sure it's a double and flatten
-    return RigidTransform(values=matrix[:3, :].astype(np.float64).ravel().tolist())
-
-
-def rigid_to_numpy(rigid: RigidTransform) -> NumpyLike:
-    """
-    Convert a proto RigidTransform into a numpy array.
-
-    Parameters
-    --------------
-    rigid
-      Transformation passed over the wire.
-
-    Returns
-    -------------
-    matrix : (4, 4) float
-      Homogeneous transformation matrix.
-    """
-    if len(rigid.values) == 0:
-        # empty messages return identity matrix
-        return np.eye(4, dtype=np.float64)
-    elif len(rigid.values) == 12:
-        # transmitted with skipped the last row
-        matrix = np.eye(4, dtype=np.float64)
-        matrix[:3, :] = np.array(rigid.values, dtype=np.float64).reshape((3, 4))
-    elif len(rigid.values) == 16:
-        matrix = np.array(rigid.values, dtype=np.float64).reshape((4, 4))
-    else:
-        raise ValueError("transforms must be 0, 12 or 16 values!")
-
-    # should be a rigid transform
-    assert np.allclose(np.dot(matrix[:3, :3], matrix[:3, :3].T), np.eye(3))
-
-    return matrix
-
-
-def numpy_to_proto(array: NumpyLike) -> NDArray:
-    """
-    Convert a `numpy.ndarray` to a `proto.NDArray` object.
-
-    Parameters
-    -----------
-    array : numpy.ndarray
-      Multidimensional array
-
-    Returns
-    ----------
-    serialized : proto.NDArray
-      Serialized ND array.
-    """
-    assert isinstance(array, np.ndarray)
-
-    # get the datatype kind
-    dtype = {"i": "int64", "f": "float64"}[array.dtype.kind]
-    return NDArray(shape=array.shape, **{dtype: array.ravel().tolist()})
-
-
-def proto_to_numpy(message: NDArray) -> NumpyLike:
-    """
-    Convert a Protobuf NDArray message to a numpy array.
-
-    Parameters
-    -----------
-    message : kerfed.protos.v1.ndarray.NDArray
-      Serialized array
-
-    Returns
-    -------------
-    array : (shape) float64 or int64
-      Data converted
-    """
-    assert isinstance(message, NDArray)
-
-    if len(message.float64) > 0:
-        return np.array(message.float64, dtype=np.float64).reshape(message.shape)
-    elif len(message.int64) > 0:
-        return np.array(message.int64, dtype=np.int64).reshape(message.shape)
-
-    raise ValueError("message contained no data!")
-
-
-def proto_to_datetime(stamp: Timestamp) -> datetime:
-    """
-    Convert a proto timestamp method to a Python datetime.
-
-    Parameters
-    -----------
-    stamp : kerfed.protos.common.v1.Timestamp
-      Over the wire proto timestamp
-
-    Returns
-    ----------
-    date : datetime
-      Native Python datetime object.
-    """
-    # utcfromtimestamp was not what I wanted even though it seemed like it.
-    return datetime.fromtimestamp(float(stamp.seconds) + float(stamp.nanos) * 1e-9)
-
-
-def datetime_to_proto(stamp: datetime) -> Timestamp:
-    """
-    Convert a native Python datetime into a proto message.
-
-    Parameters
-    --------------
-    stamp : datetime
-      Source timestamp.
-
-    Returns
-    ---------
-    proto : kerfed.protos.common.v1.Timestamp
-      Converted timestamp in proto.
-    """
-    seconds = stamp.timestamp()
-    nanos = round((seconds % 1.0) * 1e9)
-    return Timestamp(seconds=int(seconds), nanos=nanos)
-
-
-def mesh_to_proto(mesh: Trimesh) -> Geometry:
-    """
-    Convert a native Trimesh object into a proto Mesh.
-    """
-    import trimesh
-
-    if isinstance(mesh, trimesh.primitives.Box):
-        # serialized Box primitive as box
-        p = mesh.primitive
-        return Geometry(
-            box=Box(x=p.extents[0], y=p.extents[1], z=p.extents[2]),
-            transform=numpy_to_rigid(p.transform),
-        )
-    elif isinstance(mesh, trimesh.Trimesh):
-        export = mesh.export(file_type="glb")
-        # serialize mesh vertices
-        return Geometry(mesh=Mesh(blob=FileBlob(name="neutral.glb", data=export)))
-    else:
-        raise ValueError(f"unsupported kind: `{type(mesh)}`")
-
-
-def proto_to_mesh(proto: Geometry) -> Trimesh:
-    """
-    Convert a protobuf Geometry into a native Trimesh object.
-    """
-    import trimesh
-
-    if len(proto.transform.values) > 0:
-        transform = rigid_to_numpy(proto.transform)
-    else:
-        transform = None
-
-    if proto.HasField("mesh"):
-        blob = proto.mesh.blob
-        if blob.name != "neutral.glb":
-            raise ValueError(blob.name)
-        scene = trimesh.load_mesh(
-            file_obj=trimesh.util.wrap_as_stream(blob.data),
-            file_type="glb",
-            process=False,
-        )
-        assert len(scene.geometry) == 1
-        return next(iter(scene.geometry.values()))
-    elif proto.HasField("box"):
-        box = proto.box
-        return trimesh.primitives.Box(
-            extents=[box.x, box.y, box.z], transform=transform
-        )
-    else:
-        raise NotImplementedError()
-
-
-__all__ = [
-    "PostalAddress",
-    "ShippingRate",
-    "ShippingParcel",
-    "Model",
-    "Money",
-    "Order",
-    "PartFabrication",
-    "LinePrice",
-    "LineSpec",
-    "Operation",
-    "PriceMetadata",
-    "Machine",
-    "Error",
-    "Stock",
-    "StockKind",
-    "Outcome",
-    "FileBlob",
-    "NDArray",
-    "Combo",
-    "Combos",
-    "ComboDescription",
-    "Scene",
-    "Timestamp",
-    "proto_to_datetime",
-    "datetime_to_proto",
-    "GeometrySummary",
-    "FlatFabrication",
-    "AddFabrication",
-    "TurnFabrication",
-    "RollFabrication",
-    "BentFabrication",
-    "MillFabrication",
-]
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# sources: kerfed/protos/common/v1/address.proto, kerfed/protos/common/v1/brand.proto, kerfed/protos/common/v1/combo.proto, kerfed/protos/common/v1/config.proto, kerfed/protos/common/v1/cots.proto, kerfed/protos/common/v1/discount.proto, kerfed/protos/common/v1/error.proto, kerfed/protos/common/v1/fab.proto, kerfed/protos/common/v1/fileblob.proto, kerfed/protos/common/v1/geometry.proto, kerfed/protos/common/v1/machine.proto, kerfed/protos/common/v1/mill.proto, kerfed/protos/common/v1/model.proto, kerfed/protos/common/v1/money.proto, kerfed/protos/common/v1/ndarray.proto, kerfed/protos/common/v1/order.proto, kerfed/protos/common/v1/outcome.proto, kerfed/protos/common/v1/path.proto, kerfed/protos/common/v1/post.proto, kerfed/protos/common/v1/price.proto, kerfed/protos/common/v1/scene.proto, kerfed/protos/common/v1/settings.proto, kerfed/protos/common/v1/shipping.proto, kerfed/protos/common/v1/stock.proto, kerfed/protos/common/v1/timestamp.proto, kerfed/protos/common/v1/tolerance.proto, kerfed/protos/common/v1/tool.proto, kerfed/protos/common/v1/units.proto
+# plugin: python-betterproto
+# This file has been @generated
+
+from dataclasses import dataclass
+from typing import List
+
+import betterproto
+
+
+class PostKind(betterproto.Enum):
+    """a postprocessing operation: i.e. tapping, welding, etc"""
+
+    POST_KIND_UNSPECIFIED = 0
+    """an unspecified postprocessing operation (invalid)"""
+
+    POST_KIND_TAP = 1
+    """a tapped hole"""
+
+    POST_KIND_COUNTERSINK = 2
+    """a countersunk hole"""
+
+    POST_KIND_COUNTERBORE = 3
+    """a counterbored hole"""
+
+    POST_KIND_WELD = 4
+    """a welded seam"""
+
+    POST_KIND_BORE = 5
+    """a precision reamed or machined hole"""
+
+    POST_KIND_TOLERANCE = 6
+    """a tighter than default tolerance"""
+
+
+class UnitSystem(betterproto.Enum):
+    UNIT_SYSTEM_UNSPECIFIED = 0
+    """
+    If unspecified units in the parent message are assumed to be "meters-
+    kilograms-seconds"
+    """
+
+    UNIT_SYSTEM_MKS = 1
+    """All units in the parent message are `meters-kilograms-seconds`"""
+
+    UNIT_SYSTEM_IPS = 2
+    """All units in the parent message are `inches-pounds-seconds`"""
+
+
+class StockKind(betterproto.Enum):
+    STOCK_KIND_UNSPECIFIED = 0
+    STOCK_KIND_SHEET = 1
+    """A plate or sheet"""
+
+    STOCK_KIND_ROD = 2
+    """A rectangular solid"""
+
+    STOCK_KIND_BAR = 3
+    """A cylinder."""
+
+
+class ToolShape(betterproto.Enum):
+    TOOL_SHAPE_UNSPECIFIED = 0
+    TOOL_SHAPE_SQUARE_MILL = 1
+    """A cylinder."""
+
+    TOOL_SHAPE_BALL_MILL = 2
+    """A cylinder with a hemispherical end."""
+
+    TOOL_SHAPE_DRILL = 3
+    """A drill bit."""
+
+
+class SegmentTag(betterproto.Enum):
+    """The segment's role in the milling process"""
+
+    SEGMENT_TAG_UNSPECIFIED = 0
+    """must be explicitly specified."""
+
+    SEGMENT_TAG_CUT = 1
+    """
+    The segment is cutting material away, probably as a rough cut: this
+    generally translates to `G1`
+    """
+
+    SEGMENT_TAG_CUT_FINISH = 2
+    """
+    The segment is doing a finish pass, or the edges of the segment are
+    touching the finished part.
+    """
+
+    SEGMENT_TAG_CUT_PLUNGE = 3
+    """
+    The segment is doing a finish pass, or the edges of the segment are
+    touching the finished part.
+    """
+
+    SEGMENT_TAG_CUT_DRILL = 4
+    """This segment represents a drilling operation."""
+
+    SEGMENT_TAG_MOVE = 9
+    """
+    The segment is a reposition move and is not cutting material away: this
+    generall corresponds `G0`
+    """
+
+    SEGMENT_TAG_MOVE_SHORTCUT = 10
+    """
+    This is a shortcut between cutting segments and is not cutting material
+    away.
+    """
+
+    SEGMENT_TAG_MOVE_LINK = 11
+    """
+    This is a move where the intermediate region has NOT been checked for
+    collision and is relying on a postprocesser to connect or "link" the path.
+    A move with this tag MUST be checked before execution and any postprocesser
+    should immediately fail if it sees this tag.
+    """
+
+    SEGMENT_TAG_ERROR = 15
+    """
+    Some step in the path generation had an error and we tagged it as an error
+    for debugging. The G-code converter should raise an error on this and
+    refuse to output a path of any sort.
+    """
+
+    SEGMENT_TAG_SENTINEL = 16
+    """
+    This segment is a "sentinel" used for internal logic and should not be
+    included in an output.
+    """
+
+
+class GpuDetail(betterproto.Enum):
+    """
+    What voxel and toolplane resolution strategy should be used when computing
+    milled carving columes.
+    """
+
+    GPU_DETAIL_UNSPECIFIED = 0
+    """Defaults to STANDARD"""
+
+    GPU_DETAIL_DRAFT = 1
+    """Targeted to take less than 1.0 seconds."""
+
+    GPU_DETAIL_STANDARD = 2
+    """Targeted to take approximately 2.0 seconds"""
+
+    GPU_DETAIL_HIGH = 3
+    """Targeted to take less than 1 minute."""
+
+
+class FixtureStrategy(betterproto.Enum):
+    FIXTURE_STRATEGY_UNSPECIFIED = 0
+    """There is no plan, dude."""
+
+    FIXTURE_STRATEGY_VICE = 1
+    """There is a pair of parallel edges we can clamp on."""
+
+    FIXTURE_STRATEGY_CHUCK = 2
+    """There is a cylindrical surface we can clamp on."""
+
+    FIXTURE_STRATEGY_HOLDDOWN = 3
+    """Using a T-slot table and "hold-down" setup clamps."""
+
+
+@dataclass(eq=False, repr=False)
+class PostalAddress(betterproto.Message):
+    address_id: str = betterproto.string_field(1)
+    """a UUID for this postal address"""
+
+    country: str = betterproto.string_field(2)
+    """2-letter ISO3166 alpha-2 country code"""
+
+    region: str = betterproto.string_field(3)
+    """in the USA this is a state, i.e. "PA"""
+
+    city: str = betterproto.string_field(4)
+    """i.e. "Pittsburgh"""
+
+    postal_code: str = betterproto.string_field(5)
+    """in the USA this is a zip code, i.e. "15206"""
+
+    address_lines: List[str] = betterproto.string_field(6)
+    """An array of address lines i.e. ['6425 Living Pl.', 'Ste #2121']"""
+
+    recipient: str = betterproto.string_field(7)
+    """Who is recieving this package: name, company, etc."""
+
+    phone: str = betterproto.string_field(8)
+    """The phone number of the recipient."""
+
+    email: str = betterproto.string_field(9)
+    """The email address of the recipient."""
+
+    latitude: float = betterproto.double_field(15)
+    """
+    Position in degrees on the globe. Optional but if specified may skip a call
+    to the Google Places API.
+    """
+
+    longitude: float = betterproto.double_field(16)
+    place_id: str = betterproto.string_field(17)
+    """
+    The Google Place ID A place ID is a textual identifier that uniquely
+    identifies a place. The length of the identifier may vary (there is no
+    maximum length for Place IDs).
+    """
+
+
+@dataclass(eq=False, repr=False)
+class FileBlob(betterproto.Message):
+    """A file with data."""
+
+    file_id: str = betterproto.string_field(1)
+    """
+    A unique ID associated with a file that has already been uploaded to
+    kerfed.
+    """
+
+    name: str = betterproto.string_field(2)
+    """
+    The filename associated with the file, i.e. "hi.dxf". This can be used when
+    downloading the file content to disk. If available, the mediatype should be
+    preferred when determining file type.
+    """
+
+    data: bytes = betterproto.bytes_field(3)
+    """The raw binary data for the file if stored in the message."""
+
+    url: str = betterproto.string_field(4)
+    """A URL for the file data if stored remotely."""
+
+    mediatype: str = betterproto.string_field(5)
+    """
+    The Media Type associated with the file. See:
+    https://www.iana.org/assignments/media-types/media-types.xhtml
+    """
+
+    sha256: str = betterproto.string_field(6)
+    """The SHA 256 hash of the data."""
+
+
+@dataclass(eq=False, repr=False)
+class Brand(betterproto.Message):
+    """
+    Description of a brand that will be used in generated user-facing materials
+    such as drawings and documents.
+    """
+
+    brand_id: str = betterproto.string_field(1)
+    """The unique uuid key for the brand."""
+
+    name: str = betterproto.string_field(2)
+    """The display name for the brand, i.e. "JK Precision Plate"""
+
+    description: str = betterproto.string_field(3)
+    """
+    A markdown blurb describing the shop: "#JK \n We specialize in plate and
+    sheet parts."
+    """
+
+    logo: "FileBlob" = betterproto.message_field(4)
+    """The logo image for drawings, artifacts, etc."""
+
+    address: "PostalAddress" = betterproto.message_field(5)
+    """
+    Where is the shop located and contact information including email and phone
+    number.
+    """
+
+    display_units: str = betterproto.string_field(6)
+    """
+    What unit system should be displayed? Valid values include {'in', 'meter'},
+    etc. A full list of valid unit systems are available with: `import trimesh;
+    trimesh.units.keys()`
+    """
+
+
+@dataclass(eq=False, repr=False)
+class Combo(betterproto.Message):
+    """
+    A data structure which implements "aluminum-6061 comes in 0.25" or 0.5"
+    thick and can be anodized these three colors" This is translated into the
+    front-end inteface dropdown boxes. and should be transmitted to the client-
+    side unredacted.
+    """
+
+    keys: List[str] = betterproto.string_field(1)
+    """
+    the combination of config.PartConfiguration keys Note that this is a nested
+    data structure and in order to flatten it into a flat list keys alternate:
+    `[material_id, steel_hrs, finish_id]` i.e. `material_id`, `finish_id`, etc.
+    and thus *only an odd number of keys is valid.*
+    """
+
+    values: List[str] = betterproto.string_field(2)
+    """
+    i.e. `key=['material_id', 'steel_hrs', 'thickness']` then `values=[.0125,
+    0.25, 0.5, 1.0, 2.0]`
+    """
+
+
+@dataclass(eq=False, repr=False)
+class ComboDescription(betterproto.Message):
+    """ """
+
+    config_id: str = betterproto.string_field(1)
+    """i.e. 'material_id'"""
+
+    key: str = betterproto.string_field(2)
+    """i.e. 'steel_hrs'"""
+
+    label: str = betterproto.string_field(3)
+    """a display name for this config key i.e. 'Steel Hot Rolled Sheet'"""
+
+    blurb: str = betterproto.string_field(4)
+    """a note about more detail for this config option"""
+
+    color_hex: str = betterproto.string_field(5)
+    """a hex string for the color if applicable"""
+
+    link: str = betterproto.string_field(6)
+    """a web link for more information"""
+
+
+@dataclass(eq=False, repr=False)
+class Combos(betterproto.Message):
+    combos: List["Combo"] = betterproto.message_field(1)
+    """allowable configuration options"""
+
+    descriptions: List["ComboDescription"] = betterproto.message_field(2)
+    """details about each configuration option"""
+
+
+@dataclass(eq=False, repr=False)
+class PartConfiguration(betterproto.Message):
+    method_id: str = betterproto.string_field(1)
+    """i.e. 'flat', 'bent', etc"""
+
+    quantity: int = betterproto.uint32_field(2)
+    """how many of a part"""
+
+    material_id: str = betterproto.string_field(3)
+    """material key, i.e. "aluminum_6061_t6"""
+
+    finish_id: str = betterproto.string_field(4)
+    """finish key, i.e. "anodized"""
+
+    color_id: str = betterproto.string_field(5)
+    """finish color key, i.e. "blue"""
+
+    thickness_id: str = betterproto.string_field(6)
+    """discrete thickness key, i.e. "1.5mm"""
+
+    posts: List[str] = betterproto.string_field(7)
+    """selected postprocessing operations i.e. a list of `post_id` keys"""
+
+    expedite: str = betterproto.string_field(8)
+    """the expedite kind : standard, rapid, etc"""
+
+    notes: str = betterproto.string_field(9)
+    """any notes input by the user"""
+
+    cots_id: str = betterproto.string_field(10)
+    """which COTS part was selected from matches"""
+
+
+@dataclass(eq=False, repr=False)
+class Money(betterproto.Message):
+    """Represents an amount of money with its currency type."""
+
+    currency: str = betterproto.string_field(1)
+    """
+    The three-letter currency code defined in ISO-4217. if undefined it is
+    assumed to be `USD`
+    """
+
+    amount: float = betterproto.double_field(2)
+    """
+    The amount in `1/100` ("cents/pence") of the specified currency. For
+    example, if `currency` is `"USD"`, then 1 unit of amount represents one US
+    cent (1/100 dollar). Note that this is a *double* rather than an integer as
+    when these messages are serialized to JSON an `int64` would be converted to
+    a *string* as JSON does not support large integers. Our APIs will never
+    return values here that can't be represented as integers, i.e. it will
+    always be a value like `21212.0`
+    """
+
+
+@dataclass(eq=False, repr=False)
+class CotsMatch(betterproto.Message):
+    """i.e a part number on McMaster-Carr"""
+
+    cots_id: str = betterproto.string_field(1)
+    """the unique identifier for the part"""
+
+    supplier_id: str = betterproto.string_field(2)
+    """i.e. "mcmaster"""
+
+    link: str = betterproto.string_field(6)
+    """a link to the suppliers webpage"""
+
+    title: str = betterproto.string_field(7)
+    """A user-displayable label for the part."""
+
+    pack_price: "Money" = betterproto.message_field(8)
+    """the price for a PACK of this part."""
+
+    pack_size: int = betterproto.uint32_field(9)
+    """the number of this component included in a pack."""
+
+    weight_lb: float = betterproto.double_field(10)
+    """the weight of a SINGLE component."""
+
+    component_id: str = betterproto.string_field(11)
+    """A component type, like "pin," "bearing", etc."""
+
+
+@dataclass(eq=False, repr=False)
+class Discount(betterproto.Message):
+    """Represents an amount of money with its currency type."""
+
+    code: str = betterproto.string_field(1)
+    """The discount code used."""
+
+    percent: float = betterproto.double_field(2)
+    """
+    The percentage of discount. Values outside of the range (0.0, 1.0) will
+    throw errors. A value of `0.1` represents a 10% discount or $10.00 off of a
+    $100.00 order.
+    """
+
+
+@dataclass(eq=False, repr=False)
+class Error(betterproto.Message):
+    code: str = betterproto.string_field(1)
+    """i.e. "GeometryError"""
+
+    message: str = betterproto.string_field(2)
+    """a message that can be shown to the user."""
+
+
+@dataclass(eq=False, repr=False)
+class NdArray(betterproto.Message):
+    """* Represent an N dimensional array"""
+
+    shape: List[int] = betterproto.uint32_field(1)
+    """what is the shape of this array"""
+
+    float64: List[float] = betterproto.double_field(2)
+    """only one should be populated"""
+
+    int64: List[int] = betterproto.int64_field(3)
+
+
+@dataclass(eq=False, repr=False)
+class RigidTransform(betterproto.Message):
+    """A homogenous rigid transform"""
+
+    values: List[float] = betterproto.double_field(1)
+    """
+    should error if there are not exactly 12 values this is skipping the last
+    row of [0, 0, 0, 1] and in Python is `transform[:3, :].flatten()`
+    """
+
+
+@dataclass(eq=False, repr=False)
+class BilateralTolerance(betterproto.Message):
+    value: float = betterproto.float_field(1)
+    """the base value in meters, kilograms, seconds"""
+
+    minus: float = betterproto.float_field(2)
+    """
+    how much under and over *relative* in meters i.e. 0.001" = 2.54e-5 meters
+    """
+
+    plus: float = betterproto.float_field(3)
+
+
+@dataclass(eq=False, repr=False)
+class Thread(betterproto.Message):
+    is_imperial: bool = betterproto.bool_field(1)
+    """
+    if imperial mesaurements are in inches otherwise measurements are meters
+    """
+
+    description: str = betterproto.string_field(2)
+    """1/4-20"""
+
+    pitch: float = betterproto.float_field(3)
+    """distance between thread"""
+
+    radius_minor: float = betterproto.float_field(4)
+    """minor radius"""
+
+    radius_major: float = betterproto.float_field(5)
+    """major radius"""
+
+
+@dataclass(eq=False, repr=False)
+class Countersink(betterproto.Message):
+    radius: float = betterproto.float_field(1)
+    """maximum radius"""
+
+    angle: float = betterproto.float_field(2)
+    """cone angle"""
+
+
+@dataclass(eq=False, repr=False)
+class Counterbore(betterproto.Message):
+    radius: float = betterproto.float_field(1)
+    """radius of counterbore"""
+
+    depth: float = betterproto.float_field(2)
+    """how deep the counterbore goes"""
+
+
+@dataclass(eq=False, repr=False)
+class Weld(betterproto.Message):
+    length: float = betterproto.float_field(1)
+    """how long is this weld"""
+
+
+@dataclass(eq=False, repr=False)
+class Bore(betterproto.Message):
+    radius: "BilateralTolerance" = betterproto.message_field(1)
+    """what is the radius of this bore"""
+
+    depth: float = betterproto.float_field(2)
+    """how deep is this bore"""
+
+    has_reamer: bool = betterproto.bool_field(3)
+    """if this radius has a reamer that exists for it."""
+
+
+@dataclass(eq=False, repr=False)
+class Postprocess(betterproto.Message):
+    post_id: str = betterproto.string_field(1)
+    """the unique posprocessing uuid"""
+
+    geom_id: str = betterproto.string_field(2)
+    """
+    which geometry does this postprocessing operation apply to: if not included
+    should be assumed to belong to the parent message. however for operations
+    like tolerancing which is: f(repeated PartFabrication)={repeated
+    PostProcess} we need to know which geometry it's for.
+    """
+
+    method_id: str = betterproto.string_field(3)
+    """
+    which manufacturing method is this postprocessing operation valid for? i.e.
+    "flat", "bent", etc.
+    """
+
+    kind: "PostKind" = betterproto.enum_field(4)
+    """is this welding, tapping, etc."""
+
+    group: str = betterproto.string_field(5)
+    """holes can only be tapped once this looks like 'A1', 'B2', etc"""
+
+    description: str = betterproto.string_field(6)
+    """human readable text description"""
+
+    markers: "NdArray" = betterproto.message_field(7)
+    """
+    the location in part coordinates where the part should indicate the
+    operation
+    """
+
+    is_default: bool = betterproto.bool_field(8)
+    """should this postprocessing operation be selected by default"""
+
+    thread: "Thread" = betterproto.message_field(10, group="details")
+    countersink: "Countersink" = betterproto.message_field(11, group="details")
+    counterbore: "Counterbore" = betterproto.message_field(12, group="details")
+    weld: "Weld" = betterproto.message_field(13, group="details")
+    bore: "Bore" = betterproto.message_field(14, group="details")
+
+
+@dataclass(eq=False, repr=False)
+class Mesh(betterproto.Message):
+    blob: "FileBlob" = betterproto.message_field(1)
+    """A mesh in a neutral format."""
+
+
+@dataclass(eq=False, repr=False)
+class Box(betterproto.Message):
+    x: float = betterproto.double_field(1)
+    """The length of each side of the Box primitive."""
+
+    y: float = betterproto.double_field(2)
+    z: float = betterproto.double_field(3)
+
+
+@dataclass(eq=False, repr=False)
+class Cylinder(betterproto.Message):
+    radius: float = betterproto.double_field(1)
+    """The radius of the cylinder."""
+
+    height: float = betterproto.double_field(2)
+    """The *total* height of the cylinder."""
+
+
+@dataclass(eq=False, repr=False)
+class AnnularCylinder(betterproto.Message):
+    """A cylinder with a hole."""
+
+    height: float = betterproto.float_field(3)
+    """how tall this the cylinder?"""
+
+    radius_outer: float = betterproto.float_field(4)
+    """what is the radius of the outer surface?"""
+
+    radius_inner: float = betterproto.float_field(5)
+    """what is the radius of the inner bore?"""
+
+
+@dataclass(eq=False, repr=False)
+class Geometry(betterproto.Message):
+    box: "Box" = betterproto.message_field(1, group="geom")
+    cylinder: "Cylinder" = betterproto.message_field(2, group="geom")
+    annular: "AnnularCylinder" = betterproto.message_field(3, group="geom")
+    mesh: "Mesh" = betterproto.message_field(4, group="geom")
+    transform: "RigidTransform" = betterproto.message_field(10)
+    """
+    i.e. for cylinders it moves from its center of mass at the origin (i.e.
+    `z`` ranges from `-height/2` to `height/2``) to the desired location in 3D
+    space.
+    """
+
+
+@dataclass(eq=False, repr=False)
+class Outcome(betterproto.Message):
+    """
+    Indicate whether something like an analysis or pricing calculation
+    succeeded.
+    """
+
+    is_completed: bool = betterproto.bool_field(1)
+    """Is this outcome completed (is it no longer running?)"""
+
+    is_success: bool = betterproto.bool_field(2)
+    """Was this outcome successful?"""
+
+    errors: List["Error"] = betterproto.message_field(3)
+    """A list of all errors that occurred."""
+
+    quality: float = betterproto.double_field(4)
+    """
+    If there is a qualitative "quality" metric for this outcome. For example on
+    a PartFabrication message this represents how well the method can make the
+    part between 0.0-1.0. A part with pockets can be made with a waterjet but
+    only 90% of the volume can be accurately fabricated (i.e. `quality~=0.9`)
+    where a milling machine can make 100% of the volume (i.e `quality~=1.0`).
+    """
+
+    duration: float = betterproto.double_field(5)
+    """
+    If this was a billable compute call how long did the computation take?
+    """
+
+
+@dataclass(eq=False, repr=False)
+class Timestamp(betterproto.Message):
+    seconds: float = betterproto.double_field(1)
+    """
+    Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must
+    be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
+    """
+
+
+@dataclass(eq=False, repr=False)
+class Stock(betterproto.Message):
+    stock_id: str = betterproto.string_field(1)
+    """a unique identifier for this particular sheet or bar"""
+
+    material_id: str = betterproto.string_field(2)
+    """Which material does this apply to: i.e. `abs`, `aluminum_6061_t6`"""
+
+    supplier_id: str = betterproto.string_field(3)
+    """Which supplier is providing this material: `metalsdepot`, `mcmaster`"""
+
+    supplier_pn: str = betterproto.string_field(4)
+    """
+    What is the supplier's part number for this piece of material i.e.
+    `95462A515`
+    """
+
+    price: "Money" = betterproto.message_field(5)
+    """The unit cost of this material."""
+
+    expiry: "Timestamp" = betterproto.message_field(6)
+    """When does this quoted price for material expire?"""
+
+    quantity: int = betterproto.uint32_field(8)
+    """how many of this stock are required for a job"""
+
+    kind: "StockKind" = betterproto.enum_field(9)
+    """What is the simple form factor of this stock."""
+
+    length: float = betterproto.double_field(10)
+    """
+    If this is a rod `length = width` and is the diameter of the rod. If it is
+    a bar or a sheet this is the length and width.
+    """
+
+    width: float = betterproto.double_field(11)
+    height: float = betterproto.double_field(12)
+    """if this is a sheet this is the thickness."""
+
+    units: "UnitSystem" = betterproto.enum_field(15)
+    """Are all dimensions in this message meters, inches, etc."""
+
+
+@dataclass(eq=False, repr=False)
+class Interval(betterproto.Message):
+    """Define an interval with a minimum and maximum value"""
+
+    min: float = betterproto.double_field(2)
+    max: float = betterproto.double_field(3)
+
+
+@dataclass(eq=False, repr=False)
+class Model(betterproto.Message):
+    """
+    A simple `f(x) = y` defined as a serialized message. This is useful for
+    things like feed-rate curves where cutting speed is a function of
+    thickness.
+    """
+
+    kind: str = betterproto.string_field(1)
+    """i.e. `constant`, `polynomial`, `table`, `expression`"""
+
+    model_id: str = betterproto.string_field(2)
+    """
+    a globally unique identitier i.e. a UUID:
+    '83c96039-e77f-4603-a1f0-1a6381de159c'
+    """
+
+    units: List[str] = betterproto.string_field(4)
+    """
+    the units of the X and Y axis i.e. for feed rate: ["inch", "inch/minute"]
+    so if you evaluate this model with X in "inch" it produces an "inch/minute"
+    result
+    """
+
+    keys: List[float] = betterproto.float_field(5)
+    """
+    i.e for `kind=table`, `keys`` is the X value and `values` is the
+    corresponding Y value.
+    """
+
+    values: List[float] = betterproto.float_field(6)
+    expression: str = betterproto.string_field(7)
+    """
+    if we have an `expression` kind -_- i.e. "2.9 * volume_support + 1.2 *
+    volume"
+    """
+
+    is_interpolated: bool = betterproto.bool_field(8)
+    """
+    is this model allowed to be interpolated this is only used for
+    `kind="table"` where if the exact value isn't in the table it will return a
+    NaN rather than the interpolated result
+    """
+
+    limits: "Interval" = betterproto.message_field(9)
+    """
+    If this is defined enforce a range limit on the values this `Model` is
+    allowed to be evaluated over.
+    """
+
+
+@dataclass(eq=False, repr=False)
+class ToolParameters(betterproto.Message):
+    """
+    Material specific parameters which can be used for path generation.
+    Parameters are in units that are supplied from tooling suppliers
+    """
+
+    material_id: str = betterproto.string_field(1)
+    """The material ID this tool can be used for"""
+
+    surface_feet_per_minute: "Interval" = betterproto.message_field(2)
+    """
+    "surface feet per minute" The "units of art" for how the rotational speed
+    of the end mill should be correlated to the movement speed. Basically if
+    you increase the spindle speed you can increase the movement speed to keep
+    the amount of material removed per tooth of the end mill the same.
+    """
+
+    inch_per_tooth: "Interval" = betterproto.message_field(3)
+    """Inch per tooth values."""
+
+    maximum_rpm: float = betterproto.double_field(4)
+    """The cap for how fast this tool should be run."""
+
+    radial_depth_of_cut: float = betterproto.double_field(5)
+    """
+    The percentage of the radius which should be cut per pass. i.e. for a 1"
+    diameter end mill `radial_depth_of_cut=0.12` would mean steps of 12% of the
+    radius or 0.06" per step.
+    """
+
+    is_carbide: bool = betterproto.bool_field(9)
+    """Is this tool carbide or HSS?"""
+
+    flutes: int = betterproto.uint32_field(10)
+    """how many flutes does this tool have?"""
+
+    use_rough: bool = betterproto.bool_field(11)
+    """Should this be used for "roughing," or large volume removal"""
+
+    use_finish: bool = betterproto.bool_field(12)
+    """
+    Should this tool be used for finish passes, or exactly touching the surface
+    of the finish part.
+    """
+
+
+@dataclass(eq=False, repr=False)
+class Tool(betterproto.Message):
+    """Describes a tool used to cut a path."""
+
+    shape: "ToolShape" = betterproto.enum_field(1)
+    """Is this a square end mill, ball-end mill, etc."""
+
+    index: int = betterproto.uint32_field(2)
+    """When stored in a tool magazine, what is the index?"""
+
+    parameters: List["ToolParameters"] = betterproto.message_field(5)
+    """
+    The materials this tool is valid for and values that can be used to
+    calculate the "speeds and feeds" for each material.
+    """
+
+    radius: float = betterproto.double_field(6)
+    """The cutting radius in meters."""
+
+    length_cut: float = betterproto.double_field(7)
+    """What length of the tool can cut sideways."""
+
+    length_total: float = betterproto.double_field(8)
+    """What is the total length of the tool from spindle to tip."""
+
+    suppliers: List["CotsMatch"] = betterproto.message_field(9)
+    """
+    Information about where to get this tool including supplier and price.
+    """
+
+    speed_feed: float = betterproto.double_field(11)
+    """
+    If passed override linear feed rate from `ToolParameters` units are in
+    mm/min and will be passed to the `F` g-code.
+    """
+
+    speed_rpm: float = betterproto.double_field(13)
+    """
+    If passed override spindle speed from `ToolParameters` Will be passed to
+    the `S` g-code
+    """
+
+
+@dataclass(eq=False, repr=False)
+class BoundingBox3D(betterproto.Message):
+    """
+    An axis-aligned bounding box in 3d. i.e., the box defined as  lower.x <= x
+    <= upper.x &&  lower.y <= y <= upper.y &&  lower.z <= z <= upper.z
+    """
+
+    lower: "Point3D" = betterproto.message_field(1)
+    upper: "Point3D" = betterproto.message_field(2)
+
+
+@dataclass(eq=False, repr=False)
+class Point3D(betterproto.Message):
+    """A 3D point in space."""
+
+    x: float = betterproto.double_field(1)
+    y: float = betterproto.double_field(2)
+    z: float = betterproto.double_field(3)
+
+
+@dataclass(eq=False, repr=False)
+class Segment(betterproto.Message):
+    """
+    A generic segment which can be any of a helix, circular arc, or line
+    segment depending on parameter values
+    """
+
+    start: "Point3D" = betterproto.message_field(1)
+    """The starting point of the segment."""
+
+    final: "Point3D" = betterproto.message_field(2)
+    """The ending point of the segment."""
+
+    angle: float = betterproto.double_field(3)
+    """
+    What is the angle of the arc section in radians? Straight lines have an
+    angle of 0.0 This will always take the shortest arc so `angle < pi`
+    Counterclockwise arcs are positive and clockwise are negative
+    """
+
+    tag: "SegmentTag" = betterproto.enum_field(4)
+    """The segment's role e.g., removing material vs. repositioning"""
+
+    tool_index: int = betterproto.uint32_field(5)
+    """The index of the tool this segment is cut with."""
+
+    radius_override: float = betterproto.double_field(10)
+    """An override radius used for internal logic."""
+
+
+@dataclass(eq=False, repr=False)
+class ToolPlane(betterproto.Message):
+    transform: "RigidTransform" = betterproto.message_field(1)
+    """Rigid transform relative to world/material frame"""
+
+    limits: "BoundingBox3D" = betterproto.message_field(2)
+    """The limits of tool-tip motion in the above transform"""
+
+    levels: List[float] = betterproto.double_field(3)
+    """The unique depth levels consumed by this tool plane."""
+
+
+@dataclass(eq=False, repr=False)
+class SegmentPath(betterproto.Message):
+    segments: List["Segment"] = betterproto.message_field(1)
+    """Connected segments the end of a tool moves along."""
+
+    tools: List["Tool"] = betterproto.message_field(2)
+    """The library of tools each segment references in `tool_index`"""
+
+    plane: "ToolPlane" = betterproto.message_field(3)
+    """What are the details about the toolplane for these cuts."""
+
+    stats: "SegmentStatistics" = betterproto.message_field(4)
+    """How long did this path take to execute?"""
+
+
+@dataclass(eq=False, repr=False)
+class SegmentStatistics(betterproto.Message):
+    """Hold information about path duration and length."""
+
+    length: float = betterproto.double_field(1)
+    """The total path length in meters."""
+
+    duration: float = betterproto.double_field(2)
+    """
+    The duration of the path when executed at 100% of the velocity requested by
+    the tool.
+    """
+
+    tool_changes: int = betterproto.uint32_field(3)
+    """How many tool changes occurred in this path?"""
+
+
+@dataclass(eq=False, repr=False)
+class MillPlan(betterproto.Message):
+    """
+    A message containing all the information required to translate the job into
+    a full output format which initially includes a PDF plan and a `camotics`
+    simulation but could include other simulation formats (i.e. MasterCAM)
+    """
+
+    part: "Geometry" = betterproto.message_field(1)
+    """The triangulated mesh of the desired part."""
+
+    stock: "Geometry" = betterproto.message_field(2)
+    """What stock are we starting with."""
+
+    paths: List["SegmentPath"] = betterproto.message_field(3)
+    """Multiple toolpaths and fixtures."""
+
+
+@dataclass(eq=False, repr=False)
+class MillSettings(betterproto.Message):
+    material_id: str = betterproto.string_field(1)
+    """What material is this being cut from?"""
+
+    machine: "MillMachine" = betterproto.message_field(2)
+    """The machine analysis should be run with."""
+
+    tools: List["Tool"] = betterproto.message_field(3)
+    """The specific tools available."""
+
+    detail: "GpuDetail" = betterproto.enum_field(4)
+    """
+    What resolution should *roughing* operations be calculated in. Note that
+    "finish" passes are done directly from the tesselated geometry and are not
+    calculated using voxel methods.
+    """
+
+    return_volume: bool = betterproto.bool_field(5)
+    """Return the KDC file containing voxel data at each radius."""
+
+    return_gcode: bool = betterproto.bool_field(6)
+    """Calculate and return G-code toolpaths that are machine-ready."""
+
+    return_plan: bool = betterproto.bool_field(7)
+    """
+    Return a `MillPlan` object which is designed to be used programatically.
+    """
+
+    skip_fixture_collisions: bool = betterproto.bool_field(8)
+    """Check for fixture collisions."""
+
+    default_radial_depth_of_cut: float = betterproto.float_field(9)
+    """
+    If we haven't been passed an array of tools use this value for the default
+    radial depth of cut.
+    """
+
+    plane_normals: "NdArray" = betterproto.message_field(10)
+    """
+    If passed tell the preprocessor to ignore internal heuristics and use these
+    (n, 3) float array of unit vectors to assign cut planes.
+    """
+
+    skip_prune: bool = betterproto.bool_field(11)
+    """
+    The total number of operations is `len(tools) * len(preprocess.directions)`
+    as every tool is tried from every direction. This generally produces far
+    too many operations to be useful unless there is only one tool and one
+    direction but may be useful for debugging or specific applications. Pruning
+    uses the GPU to determine which tools actually cut anything *before* any
+    toolpathing and will return results that are a subset of `tools *
+    preprocess.directions`.
+    """
+
+    preprocess: "MillPreprocess" = betterproto.message_field(12)
+    """
+    The preprocessed mesh: note most applications should use our default
+    preprocessor and *not* pass this as our preprocessor does things like plug
+    drill holes and pick stock, but if you have existing internal logic you can
+    skip our heuristics by passing this explicitly.
+    """
+
+
+@dataclass(eq=False, repr=False)
+class MillMachine(betterproto.Message):
+    """
+    The parameters for a milling machine used in CarveWizard. All dimensions
+    are in meters.
+    """
+
+    tool_pad: float = betterproto.double_field(1)
+    """
+    How much to pad the tool for tool-fixture collision checks. Pads the radius
+    of the tool and the bottom of the tool.
+    """
+
+    spindle_length: float = betterproto.double_field(2)
+    """how long is the spindle cylinder for collision checks"""
+
+    spindle_radius: float = betterproto.double_field(3)
+    """What is the radius of the spindle cylinder."""
+
+    spindle_pad: float = betterproto.double_field(4)
+    """How much should the spindle be padded to avoid collisons."""
+
+    max_z_travel: float = betterproto.double_field(5)
+    """What is the maximum distance that the spindle can travel in Z?"""
+
+    extents: List[float] = betterproto.double_field(6)
+    """What is the size of the work volume of the milling machine."""
+
+    feed_max: float = betterproto.double_field(7)
+    """The maximum feed rate in meters per second."""
+
+    rpm_max: float = betterproto.double_field(8)
+    """The maximum spindle speed in rotations per minute."""
+
+
+@dataclass(eq=False, repr=False)
+class MillPreprocess(betterproto.Message):
+    """
+    Before running carving analysis we have to approximate certain information.
+    """
+
+    directions: "NdArray" = betterproto.message_field(2)
+    """
+    an ordered (n, 3) double array of unit vectors of possible directions.
+    """
+
+    stock: "Stock" = betterproto.message_field(3)
+    """What is the stock material this is being constructed out of?"""
+
+    stock_geometry: "Geometry" = betterproto.message_field(4)
+    """A model of the stock in the frame of the preprocessed mesh."""
+
+    mesh: "Geometry" = betterproto.message_field(5)
+    """The preprocessor may have edited the geometry."""
+
+    drills: List["CutDrill"] = betterproto.message_field(6)
+    """
+    The preprocessor may have extracted drill cuts as these are a special case
+    that generally does not
+    """
+
+    collision: List["Geometry"] = betterproto.message_field(7)
+    """Collision geometry to avoid. Must be the same length as `directions`"""
+
+
+@dataclass(eq=False, repr=False)
+class Fixture(betterproto.Message):
+    strategy: "FixtureStrategy" = betterproto.enum_field(1)
+    """What strategy is this fixture using?"""
+
+    collision: "Geometry" = betterproto.message_field(2)
+    """Collision geometry for this fixture."""
+
+    normal: List[float] = betterproto.double_field(3)
+    """What is the normal vector of this fixture operation."""
+
+
+@dataclass(eq=False, repr=False)
+class CutMill(betterproto.Message):
+    volume: float = betterproto.double_field(1)
+    """Volume remove for each radius of the mill cut."""
+
+    radius: float = betterproto.double_field(2)
+    """Radius of the tool in meters."""
+
+    tool: "Tool" = betterproto.message_field(3)
+    """What tool was this operation using."""
+
+
+@dataclass(eq=False, repr=False)
+class CutDrill(betterproto.Message):
+    radius: float = betterproto.double_field(1)
+    """Which drill bit radius is used?"""
+
+    depth: List[float] = betterproto.double_field(2)
+    """How deep is each hole?"""
+
+    origins: "NdArray" = betterproto.message_field(3)
+    """Where is the origin for each hole"""
+
+    normal: List[float] = betterproto.double_field(4)
+    """What is the normal vector for each hole?"""
+
+    thru: bool = betterproto.bool_field(5)
+    """Are these drilled holes through the entire part?"""
+
+    labels: List[str] = betterproto.string_field(6)
+    """What are the labels for the drill, i.e. "17/64 Drill"""
+
+
+@dataclass(eq=False, repr=False)
+class CutFace(betterproto.Message):
+    radius: float = betterproto.double_field(1)
+    """The radius of the face-mill cutter."""
+
+    area: float = betterproto.double_field(2)
+    """The area to be faced."""
+
+    depth: float = betterproto.double_field(3)
+    """The depth to be faced."""
+
+
+@dataclass(eq=False, repr=False)
+class MillFabrication(betterproto.Message):
+    """This is an analysis result suitable for quoting."""
+
+    stock: "Stock" = betterproto.message_field(1)
+    """What is the raw material this part was milled from?"""
+
+    fixtures: List["Fixture"] = betterproto.message_field(2)
+    """How is this part being held to cut?"""
+
+    cuts: List["MillFabricationCut"] = betterproto.message_field(3)
+    """Ordered list of operations required to generate this part."""
+
+    volume: "FileBlob" = betterproto.message_field(4)
+    """the volumetric carving information in KDC format"""
+
+    gcode: List["FileBlob"] = betterproto.message_field(5)
+    """
+    The "G-code" for the milled part in addition to supporting files. There is
+    one G-code file per tool plane and a corresponding Camotics simulation
+    definition for each toolplane.
+    """
+
+    plan: "MillPlan" = betterproto.message_field(6)
+    """
+    The same data as in the G-code but in an internal machine-usable format.
+    """
+
+    pre: "MillPreprocess" = betterproto.message_field(7)
+    """The preprocessor information that was used."""
+
+    machine: "MillMachine" = betterproto.message_field(8)
+    """The machine that this fabrication was calculated for."""
+
+
+@dataclass(eq=False, repr=False)
+class MillFabricationCut(betterproto.Message):
+    mill: "CutMill" = betterproto.message_field(1, group="op")
+    drill: "CutDrill" = betterproto.message_field(2, group="op")
+    face: "CutFace" = betterproto.message_field(3, group="op")
+    fixture_index: int = betterproto.uint32_field(5)
+    """Which fixturing setup is this operation using."""
+
+    label: str = betterproto.string_field(6)
+    """What is a human-readable label for this operation?"""
+
+
+@dataclass(eq=False, repr=False)
+class FlatFabrication(betterproto.Message):
+    perimeter: float = betterproto.double_field(1)
+    """How long is the internal *and* external boundary."""
+
+    holes: List[float] = betterproto.double_field(2)
+    """
+    The size of the largest dimension of the axis-aligned bounding box for each
+    interior curve of the flat pattern.
+    """
+
+    extents: List[float] = betterproto.double_field(3)
+    """The (2,) oriented bounding box size of the flat pattern."""
+
+    area: float = betterproto.double_field(4)
+    """The area of the flat pattern."""
+
+    rapids: float = betterproto.double_field(5)
+    """
+    How much distance is there in a path that visits every interior of the flat
+    pattern.
+    """
+
+    thickness: float = betterproto.double_field(6)
+    """How thick was the original geometry."""
+
+    flattened: "FileBlob" = betterproto.message_field(7)
+    """
+    The flattened geometry most likely as our internal SVG format which
+    preserves metadata.
+    """
+
+    to_flattened: "RigidTransform" = betterproto.message_field(8)
+    """
+    A (4, 4) homogeneous rigid transform. In 3D the geometry of the source
+    geometry of a plate-with-holes is in an entirely arbitrary position and
+    rotation. When we generate the flat pattern and save it as
+    `FlatFabrication.flattened`, it is originally a projection onto a plane in
+    that arbitrary frame this transform moves the arbitrary frame onto the XY
+    plane. The scene graph may contain multiple instances of that geometry, and
+    we use this transform in the tolerance calculation to move every 2D hole on
+    the plane into the full 3D scene graph.
+    """
+
+
+@dataclass(eq=False, repr=False)
+class CotsFabrication(betterproto.Message):
+    """A commercial-off-the-shelf part like a ball bearing."""
+
+    matches: List["CotsMatch"] = betterproto.message_field(1)
+    """
+    the part can match to many different commerical parts and the same part
+    from a different supplier is a different match.
+    """
+
+    cylinder: "Cylinder" = betterproto.message_field(4, group="primitive")
+    annular: "AnnularCylinder" = betterproto.message_field(5, group="primitive")
+
+
+@dataclass(eq=False, repr=False)
+class BentFabrication(betterproto.Message):
+    """A part fabricated on a press-brake."""
+
+    bend_count: int = betterproto.uint32_field(1)
+    """How many individual bend operations are there?"""
+
+    bend_setups: int = betterproto.uint32_field(2)
+    """
+    How many bend setups are there? These numbers are different because
+    sometimes bends can be combined into a single setup operation if they are
+    colinear and have the same radius.
+    """
+
+    bend_k: List[float] = betterproto.float_field(3)
+    """what K-factor was the part flattened with."""
+
+    bend_angle: List[float] = betterproto.float_field(4)
+    """What is the angle of each bend?"""
+
+    bend_radii: List[float] = betterproto.float_field(5)
+    """What is the radius of each bend?"""
+
+    flat: "FlatFabrication" = betterproto.message_field(6)
+    """The details of the flat pattern."""
+
+    regions: "BentFabricationBentRegions" = betterproto.message_field(7)
+    """what is the transform for each region back into 3D space"""
+
+
+@dataclass(eq=False, repr=False)
+class BentFabricationBentRegions(betterproto.Message):
+    wkt: str = betterproto.string_field(1)
+    """a MultiPolygon outline in the "well known text" format"""
+
+    to_3_d: "NdArray" = betterproto.message_field(2)
+    """
+    a matrix to move each polygon back into 3D (len(wkt.geoms), 4, 4) float
+    """
+
+
+@dataclass(eq=False, repr=False)
+class ManualFabrication(betterproto.Message):
+    """A manual fabrication is a placeholder."""
+
+    pass
+
+
+@dataclass(eq=False, repr=False)
+class RollFabrication(betterproto.Message):
+    """
+    A part cut from a flat sheet and then rolled into a cylinder with cutouts.
+    """
+
+    height: float = betterproto.double_field(1)
+    """The maximum height of the rolled cylinder in inches."""
+
+    diameter: float = betterproto.double_field(2)
+    """The exterior diameter of the resulting rolled part."""
+
+    flat: "FlatFabrication" = betterproto.message_field(3)
+    """The details of the flat pattern."""
+
+
+@dataclass(eq=False, repr=False)
+class TurnFabrication(betterproto.Message):
+    """A part made entirely on a lathe with no milled features."""
+
+    height: float = betterproto.double_field(1)
+    """the maximum height of the part in inches"""
+
+    diameter: float = betterproto.double_field(2)
+    """the bounding cylinder diameter."""
+
+    volume: float = betterproto.double_field(3)
+    """The final part volume."""
+
+    inner_diameter: float = betterproto.double_field(4)
+    """if there is a thru-bore what is the minimum diameter."""
+
+    profile: "FileBlob" = betterproto.message_field(5)
+    """the 2D profile geometry"""
+
+
+@dataclass(eq=False, repr=False)
+class AddFabrication(betterproto.Message):
+    """
+    A part made through additive fabrication methods also known as
+    "3D-printing."
+    """
+
+    planes: List["AddFabricationPlane"] = betterproto.message_field(5)
+    """the different printing plane options."""
+
+
+@dataclass(eq=False, repr=False)
+class AddFabricationPlane(betterproto.Message):
+    """
+    A printed part can be aligned with different print planes which will effect
+    the final part geometry as well as the amount of support material used.
+    """
+
+    origin: List[float] = betterproto.float_field(1)
+    """The (3,) position of the plane origin."""
+
+    normal: List[float] = betterproto.float_field(2)
+    """The (3,) unit vector for the plane normal."""
+
+    area: float = betterproto.double_field(3)
+    """The projected area of the part onto this plane."""
+
+    height: float = betterproto.double_field(4)
+    """The height this part rises above the plane."""
+
+    extents: List[float] = betterproto.float_field(5)
+    """The (2,) oriented bounding box size on this plane."""
+
+    volume: float = betterproto.double_field(6)
+    """
+    the total volume of the resulting part when printed against this plane.
+    """
+
+    volume_support: float = betterproto.double_field(7)
+    """
+    The amount of overhung "support" volume when this part is printed against
+    this plane.
+    """
+
+
+@dataclass(eq=False, repr=False)
+class PartFabrication(betterproto.Message):
+    """The overall methods a part may be manufactured with."""
+
+    geom_id: str = betterproto.string_field(1)
+    """Which geometry identifier does this part refer to."""
+
+    geom_name: str = betterproto.string_field(2)
+    """if this geometry has a human-readable name store it here"""
+
+    method_id: str = betterproto.string_field(3)
+    """Which of the `PartFabrication.details` is populated?"""
+
+    outcome: "Outcome" = betterproto.message_field(4)
+    """How well did the fabrication by this method work."""
+
+    defaults: "PartConfiguration" = betterproto.message_field(5)
+    """what are the default values for this part"""
+
+    posts: List["Postprocess"] = betterproto.message_field(6)
+    """The `method_id`-specific postprocessing options."""
+
+    drawing: "FileBlob" = betterproto.message_field(7)
+    """The `method_id`-specific 2D drawing to show to the user."""
+
+    extents: List[float] = betterproto.double_field(8)
+    """The 3D size of the final part in *meters*"""
+
+    flat: "FlatFabrication" = betterproto.message_field(10, group="details")
+    bent: "BentFabrication" = betterproto.message_field(11, group="details")
+    roll: "RollFabrication" = betterproto.message_field(12, group="details")
+    mill: "MillFabrication" = betterproto.message_field(13, group="details")
+    cots: "CotsFabrication" = betterproto.message_field(14, group="details")
+    add: "AddFabrication" = betterproto.message_field(15, group="details")
+    turn: "TurnFabrication" = betterproto.message_field(16, group="details")
+    manual: "ManualFabrication" = betterproto.message_field(17, group="details")
+
+
+@dataclass(eq=False, repr=False)
+class MaterialConfig(betterproto.Message):
+    """
+    A message for a machine indicating how it performs on specific materials,
+    i.e. to calculate the feed rate on 0.25" thick aluminum.
+    """
+
+    material_id: str = betterproto.string_field(1)
+    """
+    which material does this config correspond to, i.e. `aluminum_6061_t6`
+    """
+
+    model_id: str = betterproto.string_field(2)
+    """
+    which model does this material use? i.e.
+    `01f563b5-cb25-4e74-9765-49adb891d26f``
+    """
+
+    model_use: str = betterproto.string_field(3)
+    """
+    what is this model used for in this instance i.e. `pierce`, `feed`,
+    `rapids`
+    """
+
+
+@dataclass(eq=False, repr=False)
+class Machine(betterproto.Message):
+    """A machine which can be used to cut various parts."""
+
+    machine_id: str = betterproto.string_field(1)
+    """What is the unique identifier for this machine i.e. `laser2k`"""
+
+    label: str = betterproto.string_field(2)
+    """
+    What is the user-facing name of the machine i.e. "2kW Amada Fiber Laser"
+    """
+
+    method_id: str = betterproto.string_field(3)
+    """Which process is this machine for. i.e. `flat`, `bent`, etc"""
+
+    shop_id: str = betterproto.string_field(4)
+    """Which shop does this machine belong to. i.e. `atomatic`"""
+
+    address_id: str = betterproto.string_field(6)
+    """Where is this machine physically located?"""
+
+    work_rate: "Money" = betterproto.message_field(7)
+    """
+    How much does this machine bill the customer in units of `Money / second`
+    """
+
+    setups: str = betterproto.string_field(8)
+    """
+    How long does this machine take to set up in seconds? this is a `model_id`
+    contained in `Machine.models`
+    """
+
+    rapids: str = betterproto.string_field(9)
+    """
+    What is the maximum speed this machine can move a distance? this is a
+    `model_id` contained in `Machine.models`
+    """
+
+    extents: List[float] = betterproto.double_field(10)
+    """What is the largest part this machine can handle?"""
+
+    materials: List["MaterialConfig"] = betterproto.message_field(11)
+    """
+    Which materials correspond to which cutting models keyed {'material_id':
+    {'model_name': 'model_id'}} i.e. `{'aluminum_6061_t6`: {'pierce':
+    '000-00'}}`
+    """
+
+    models: List["Model"] = betterproto.message_field(12)
+    """
+    includes the per-material cost information, such as feed rate curves,
+    pierce time curves, setup times, etc. these are stored separately from
+    materials as many of them are duplicates (i.e. different aluminum alloys)
+    keyed {'model_id': Model}
+    """
+
+
+@dataclass(eq=False, repr=False)
+class Operation(betterproto.Message):
+    """An operation which"""
+
+    operation_id: str = betterproto.string_field(1)
+    """if we were tracking these in an ERP system"""
+
+    price: "Money" = betterproto.message_field(2)
+    """how much does this component of the price cost?"""
+
+    is_combinable: bool = betterproto.bool_field(3)
+    """
+    Is this a "combinable setup" if this part of the price needs to be filled
+    in later for example setups will be combined at the bottom of the invoice
+    rather than listed as a subcomponent here if true: price represents ceil(
+    sum(utilization) ) * price
+    """
+
+    duration: float = betterproto.double_field(4)
+    """
+    how long did this operation take in seconds if `combine=True` this is the
+    length of 1.0 utilization
+    """
+
+    utilization: float = betterproto.double_field(5)
+    """
+    how much of this setup does ONE part consume ONLY used if `combine=True`
+    """
+
+    note: str = betterproto.string_field(6)
+    """
+    a user-facing note about this price i.e. "Amada 4kW Fiber Laser, 10 "
+    """
+
+
+@dataclass(eq=False, repr=False)
+class LinePrice(betterproto.Message):
+    line_id: str = betterproto.string_field(1)
+    """the unique identifier for the part this price is for"""
+
+    geom_id: str = betterproto.string_field(2)
+    """the geometry this price was generated for"""
+
+    method_id: str = betterproto.string_field(3)
+    """the fabrication method this is valid for, i.e. `flat`"""
+
+    shop_id: str = betterproto.string_field(4)
+    """what vendor is producing this part"""
+
+    address_id: str = betterproto.string_field(5)
+    """where exactly is this part being produced"""
+
+    price: "Money" = betterproto.message_field(6)
+    """the *unit* price of the part"""
+
+    quantity: int = betterproto.uint32_field(7)
+    """this price is *only valid at a specific quantity.*"""
+
+    mass: float = betterproto.double_field(8)
+    """how much does the *each* part weigh in *kilograms*"""
+
+    extents: List[float] = betterproto.double_field(9)
+    """how large is *each* part in *meters*"""
+
+    stock: "Stock" = betterproto.message_field(10)
+    """the raw material input `stock` the part was made from."""
+
+    operations: List["Operation"] = betterproto.message_field(11)
+    """
+    if a part consists of "buy metal sheet, cut on laser, ..." return a list of
+    these operations which can be displayed to the user as an "itemized" price
+    or can be used when released to manufacturing as a "todo list". ERP systems
+    sometimes have the list of operations with a signature and barcode next to
+    each op and we could do a thing with a QR code if desired.
+    """
+
+    outcome: "Outcome" = betterproto.message_field(12)
+    """If this price had an error list here."""
+
+
+@dataclass(eq=False, repr=False)
+class LineSpec(betterproto.Message):
+    """a fully configured part ready to be released to manufacturing"""
+
+    line_id: str = betterproto.string_field(1)
+    """globally unique identifier for this part"""
+
+    geom_id: str = betterproto.string_field(2)
+    """
+    locally unique identifier which indicates which geometry in the local
+    scenes this is
+    """
+
+    shop_id: str = betterproto.string_field(3)
+    """which shop is assigned to make this part"""
+
+    name: str = betterproto.string_field(4)
+    """nicer display name"""
+
+    fab: "PartFabrication" = betterproto.message_field(10)
+    """fabrication data from analysis pipeline"""
+
+    config: "PartConfiguration" = betterproto.message_field(11)
+    """full configuration that can be priced"""
+
+
+@dataclass(eq=False, repr=False)
+class OrderPrice(betterproto.Message):
+    total: "Money" = betterproto.message_field(1)
+    """the sum price the customer was billed"""
+
+    lines: "Money" = betterproto.message_field(2)
+    """the sum price of all parts in this order"""
+
+    setups: "Money" = betterproto.message_field(3)
+    """the sum of all setups after combining"""
+
+    shipping: "Money" = betterproto.message_field(4)
+    """total shipping cost billed to customer"""
+
+    taxes: "Money" = betterproto.message_field(5)
+    """taxes billed to customer"""
+
+    discount: "Money" = betterproto.message_field(6)
+    """discount, usually negative: note that it is signed"""
+
+
+@dataclass(eq=False, repr=False)
+class PriceMetadata(betterproto.Message):
+    """Contains mappings of IDs to metadata used for pricing."""
+
+    stock: List["Stock"] = betterproto.message_field(1)
+    """
+    The available stock materials that can be used by the configured parts.
+    """
+
+    machines: List["Machine"] = betterproto.message_field(2)
+    """The available machines that can be used to cut the parts."""
+
+    addresses: List["PostalAddress"] = betterproto.message_field(3)
+    """what are the facilities that are mailing stuff."""
+
+
+@dataclass(eq=False, repr=False)
+class ShippingRate(betterproto.Message):
+    """a rate is a fully-quoted purchasable shipping option."""
+
+    price: "Money" = betterproto.message_field(3)
+    """how much does this method cost in total"""
+
+    parcels: List["ShippingParcel"] = betterproto.message_field(4)
+    """may contain different shippers"""
+
+
+@dataclass(eq=False, repr=False)
+class ShippingParcel(betterproto.Message):
+    ship_from: "PostalAddress" = betterproto.message_field(1)
+    ship_to: "PostalAddress" = betterproto.message_field(2)
+    line_id: List[str] = betterproto.string_field(3)
+    """which of the LinePrice parts are contained in this parcel."""
+
+    extents: List[float] = betterproto.double_field(4)
+    """the 3D bounding box for one parcel in meters"""
+
+    weight: float = betterproto.double_field(5)
+    """the weight of the parcel in kilograms"""
+
+    provider: str = betterproto.string_field(6)
+    """i.e. "shippo", "shipengine", "easypost"""
+
+    provider_id: str = betterproto.string_field(7)
+    """the unique identifier used to purchase the label"""
+
+    label: "FileBlob" = betterproto.message_field(8)
+    """i.e. a PNG shipping label (Only populated after purchase.)"""
+
+    tracking_url: str = betterproto.string_field(9)
+    """a tracking url (Only populated after purchase.)"""
+
+
+@dataclass(eq=False, repr=False)
+class GeometrySummary(betterproto.Message):
+    """A summary of a single geometry found in the scene."""
+
+    geom_id: str = betterproto.string_field(1)
+    """the re-usable id assigned to the geometry"""
+
+    node_id: List[str] = betterproto.string_field(2)
+    """a reference to the geometry instance being referenced"""
+
+    name: str = betterproto.string_field(3)
+    """the human-readable name of the geometry"""
+
+    preview: "FileBlob" = betterproto.message_field(4)
+    """If requested a raster image preview."""
+
+
+@dataclass(eq=False, repr=False)
+class Scene(betterproto.Message):
+    """One or more 2D or 3D parts represented as a single geometry file."""
+
+    neutral: "FileBlob" = betterproto.message_field(1)
+    """
+    one or more files in a neutral format, currently: `glb` for 3D `svg` for 2D
+    """
+
+    name: str = betterproto.string_field(2)
+    """The name of the scene, usually set to the input filename."""
+
+    geometries: List["GeometrySummary"] = betterproto.message_field(3)
+    """which geometry is contained in this scene"""
+
+    preview: "FileBlob" = betterproto.message_field(4)
+    """If raster images were requested."""
+
+
+@dataclass(eq=False, repr=False)
+class Order(betterproto.Message):
+    """a placed order"""
+
+    order_id: str = betterproto.string_field(1)
+    """the uuid with hyphens"""
+
+    shop_id: str = betterproto.string_field(2)
+    """the id of the shop the *order was placed from*"""
+
+    shipping: "PostalAddress" = betterproto.message_field(3)
+    """where is order shipped to"""
+
+    billing: "PostalAddress" = betterproto.message_field(4)
+    """where is order billed to"""
+
+    lines: List["LineSpec"] = betterproto.message_field(5)
+    """fully configured parts in the order"""
+
+    prices: List["LinePrice"] = betterproto.message_field(6)
+    """the corresponding prices for the parts"""
+
+    models: List["Scene"] = betterproto.message_field(9)
+    """the models for the parts"""
+
+    originals: List["FileBlob"] = betterproto.message_field(10)
+    """the original CAD files for the order"""
+
+    parcels: List["ShippingParcel"] = betterproto.message_field(11)
+    """the parcels this order is shipping with"""
+
+
+@dataclass(eq=False, repr=False)
+class Job(betterproto.Message):
+    """a Job is a released-to-manufacture package"""
+
+    shop_id: str = betterproto.string_field(1)
+    """which shop is making this"""
+
+    order_id: str = betterproto.string_field(2)
+    """which order was this job created from"""
+
+    job_id: str = betterproto.string_field(3)
+    """unique identifier for this job"""
+
+    part_id: List[str] = betterproto.string_field(4)
+    """the parts being manufactured by this job"""
+
+    amount: "Money" = betterproto.message_field(5)
+    """
+    the total amount of money that will be disbursed to the shop on completion
+    shipping which will be either paid by us or invoiced separately.
+    """
+
+    summary: "FileBlob" = betterproto.message_field(6)
+    """A PDF document with quantities, drawings shipping labels, etc."""
+
+    files: List["FileBlob"] = betterproto.message_field(7)
+    """
+    any additional reference files, including flattened DXF drawings, original
+    models, etc.
+    """
+
+    parcels: List["ShippingParcel"] = betterproto.message_field(8)
+    """the parcels this order is shipping with"""
+
+
+@dataclass(eq=False, repr=False)
+class FabricationSettings(betterproto.Message):
+    """A configuration for the manufacturing analysis."""
+
+    method_id: List[str] = betterproto.string_field(1)
+    """
+    Specify which methods you want the pipeline to analyze. If unspecified will
+    run and return all methods. Valid options include: `mill`, `flat`, `bent`,
+    `roll`, `add`, `cots`.
+    """
+
+    mill: "MillSettings" = betterproto.message_field(2)
+    """Detailed settings for the milling geometry"""
+
+    bent: "BendSettings" = betterproto.message_field(3)
+    """Settings for flattening objects, including K-factors, etc"""
+
+    flat: "FlatSettings" = betterproto.message_field(4)
+    """Settings for flat pattern outputs."""
+
+
+@dataclass(eq=False, repr=False)
+class KFactor(betterproto.Message):
+    """
+    Bent parts have flat patterns produced using these material and radius-
+    ratio specific settings.
+    """
+
+    material_id: str = betterproto.string_field(1)
+    """
+    a material id match pattern string like `aluminum_6061_t6` or including
+    wildcards like `aluminum_*`.
+    """
+
+    radius_fraction: List[float] = betterproto.double_field(2)
+    """What is the ratio of bend radius to sheet thickness."""
+
+    k_factor: List[float] = betterproto.double_field(3)
+    """
+    what is the k-factor at that ratio? 0.5 means flatten at the centerline of
+    the sheet. 0.0 means flatten at the inner surface of the bend.
+    """
+
+
+@dataclass(eq=False, repr=False)
+class BendSettings(betterproto.Message):
+    k_factor: List["KFactor"] = betterproto.message_field(4)
+    """For bent sheet metal parts."""
+
+
+@dataclass(eq=False, repr=False)
+class FlatSettings(betterproto.Message):
+    undersize_holes: float = betterproto.double_field(1)
+    """
+    undersize any "holes" or "interior region that is circular" example:
+    `hole_diameter=1.0`, `undersize_holes=0.125` the output geometry would have
+    a hole diameter of `0.875`
+    """
+
+
+@dataclass(eq=False, repr=False)
+class DisbursementPolicy(betterproto.Message):
+    """A model for disbursing funds."""
+
+    fee_percent: float = betterproto.double_field(1)
+    """A percentage fee per-transactions where 1.0% = 0.01"""
+
+    fee_fixed: "Money" = betterproto.message_field(2)
+    """A fixed fee per-transaction in USD."""
+
+    fee_monthly: "Money" = betterproto.message_field(3)
+    """A fixed fee if the shop is billed monthly."""
+
+    cc_percent: float = betterproto.double_field(4)
+    """
+    Credit card charge rate from supplier. For stripe this is 2.9% + $0.30 per
+    transaction.
+    """
+
+    cc_fixed: "Money" = betterproto.message_field(5)
+    """What is the fixed charge per credit card transaction."""
```

