# Comparing `tmp/lazylinop-1.7.1-py3-none-any.whl.zip` & `tmp/lazylinop-1.8.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,47 +1,49 @@
-Zip file size: 107120 bytes, number of entries: 45
--rw-r--r--  2.0 unx      126 b- defN 24-Apr-12 14:49 lazylinop/__init__.py
--rw-r--r--  2.0 unx     8275 b- defN 24-Apr-12 14:49 lazylinop/check_op.py
--rw-r--r--  2.0 unx    52187 b- defN 24-Apr-12 14:49 lazylinop/lazylinop.py
--rw-r--r--  2.0 unx      370 b- defN 24-Apr-12 14:49 lazylinop/basicops/__init__.py
--rw-r--r--  2.0 unx     1508 b- defN 24-Apr-12 14:49 lazylinop/basicops/add.py
--rw-r--r--  2.0 unx     2255 b- defN 24-Apr-12 14:49 lazylinop/basicops/blockdiag.py
--rw-r--r--  2.0 unx     1852 b- defN 24-Apr-12 14:49 lazylinop/basicops/cat.py
--rw-r--r--  2.0 unx    11699 b- defN 24-Apr-12 14:49 lazylinop/basicops/diag.py
--rw-r--r--  2.0 unx     3406 b- defN 24-Apr-12 14:49 lazylinop/basicops/eye.py
--rw-r--r--  2.0 unx     3792 b- defN 24-Apr-12 14:49 lazylinop/basicops/kron.py
--rw-r--r--  2.0 unx     2309 b- defN 24-Apr-12 14:49 lazylinop/basicops/ones.py
--rw-r--r--  2.0 unx    31288 b- defN 24-Apr-12 14:49 lazylinop/basicops/pad.py
--rw-r--r--  2.0 unx     1573 b- defN 24-Apr-12 14:49 lazylinop/basicops/zeros.py
--rw-r--r--  2.0 unx       78 b- defN 24-Apr-12 14:49 lazylinop/wip/__init__.py
--rw-r--r--  2.0 unx     1443 b- defN 24-Apr-12 14:49 lazylinop/wip/code_optimization.py
--rw-r--r--  2.0 unx     1447 b- defN 24-Apr-12 14:49 lazylinop/wip/linear_algebra.py
--rw-r--r--  2.0 unx    68835 b- defN 24-Apr-12 14:49 lazylinop/wip/polynomial.py
--rw-r--r--  2.0 unx   133585 b- defN 24-Apr-12 14:49 lazylinop/wip/signal.py
--rw-r--r--  2.0 unx    57938 b- defN 24-Apr-12 14:49 lazylinop/wip/special_matrices.py
--rw-r--r--  2.0 unx       52 b- defN 24-Apr-12 14:49 lazylinop/wip/basicops/__init__.py
--rw-r--r--  2.0 unx     1607 b- defN 24-Apr-12 14:49 lazylinop/wip/basicops/average.py
--rw-r--r--  2.0 unx      573 b- defN 24-Apr-12 14:49 lazylinop/wip/basicops/mean.py
--rw-r--r--  2.0 unx      298 b- defN 24-Apr-12 14:49 lazylinop/wip/linalg/__init__.py
--rw-r--r--  2.0 unx     4792 b- defN 24-Apr-12 14:49 lazylinop/wip/linalg/coshm.py
--rw-r--r--  2.0 unx     2820 b- defN 24-Apr-12 14:49 lazylinop/wip/linalg/cosm.py
--rw-r--r--  2.0 unx     4237 b- defN 24-Apr-12 14:49 lazylinop/wip/linalg/expm.py
--rw-r--r--  2.0 unx     5587 b- defN 24-Apr-12 14:49 lazylinop/wip/linalg/khatri_rao.py
--rw-r--r--  2.0 unx     4667 b- defN 24-Apr-12 14:49 lazylinop/wip/linalg/logm.py
--rw-r--r--  2.0 unx     4694 b- defN 24-Apr-12 14:49 lazylinop/wip/linalg/sinhm.py
--rw-r--r--  2.0 unx     2827 b- defN 24-Apr-12 14:49 lazylinop/wip/linalg/sinm.py
--rw-r--r--  2.0 unx     1582 b- defN 24-Apr-12 14:49 lazylinop/wip/linalg/spectral_norm.py
--rw-r--r--  2.0 unx     3754 b- defN 24-Apr-12 14:49 lazylinop/wip/linalg/sqrtm.py
--rw-r--r--  2.0 unx      253 b- defN 24-Apr-12 14:49 lazylinop/wip/parallel/__init__.py
--rw-r--r--  2.0 unx     8328 b- defN 24-Apr-12 14:49 lazylinop/wip/parallel/mpilop.py
--rw-r--r--  2.0 unx     4897 b- defN 24-Apr-12 14:49 lazylinop/wip/parallel/pmatmat.py
--rw-r--r--  2.0 unx     4250 b- defN 24-Apr-12 14:49 lazylinop/wip/parallel/pmatmat_mpi.py
--rw-r--r--  2.0 unx     5902 b- defN 24-Apr-12 14:49 lazylinop/wip/parallel/pmatmat_process.py
--rw-r--r--  2.0 unx     3306 b- defN 24-Apr-12 14:49 lazylinop/wip/parallel/pmatmat_thread.py
--rw-r--r--  2.0 unx       23 b- defN 24-Apr-12 14:49 lazylinop/wip/random/__init__.py
--rw-r--r--  2.0 unx     6721 b- defN 24-Apr-12 14:49 lazylinop/wip/random/rand.py
--rw-r--r--  2.0 unx     1434 b- defN 24-Apr-12 14:49 lazylinop-1.7.1.dist-info/LICENSE.txt
--rw-r--r--  2.0 unx     8177 b- defN 24-Apr-12 14:49 lazylinop-1.7.1.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Apr-12 14:49 lazylinop-1.7.1.dist-info/WHEEL
--rw-r--r--  2.0 unx       10 b- defN 24-Apr-12 14:49 lazylinop-1.7.1.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     3855 b- defN 24-Apr-12 14:49 lazylinop-1.7.1.dist-info/RECORD
-45 files, 468704 bytes uncompressed, 100974 bytes compressed:  78.5%
+Zip file size: 108873 bytes, number of entries: 47
+-rw-r--r--  2.0 unx      152 b- defN 24-Apr-14 06:54 lazylinop/__init__.py
+-rw-r--r--  2.0 unx     8275 b- defN 24-Apr-14 06:54 lazylinop/check_op.py
+-rw-r--r--  2.0 unx    52187 b- defN 24-Apr-14 06:54 lazylinop/lazylinop.py
+-rw-r--r--  2.0 unx      370 b- defN 24-Apr-14 06:54 lazylinop/basicops/__init__.py
+-rw-r--r--  2.0 unx     1508 b- defN 24-Apr-14 06:54 lazylinop/basicops/add.py
+-rw-r--r--  2.0 unx     2255 b- defN 24-Apr-14 06:54 lazylinop/basicops/blockdiag.py
+-rw-r--r--  2.0 unx     1852 b- defN 24-Apr-14 06:54 lazylinop/basicops/cat.py
+-rw-r--r--  2.0 unx    11699 b- defN 24-Apr-14 06:54 lazylinop/basicops/diag.py
+-rw-r--r--  2.0 unx     3406 b- defN 24-Apr-14 06:54 lazylinop/basicops/eye.py
+-rw-r--r--  2.0 unx     3792 b- defN 24-Apr-14 06:54 lazylinop/basicops/kron.py
+-rw-r--r--  2.0 unx     2309 b- defN 24-Apr-14 06:54 lazylinop/basicops/ones.py
+-rw-r--r--  2.0 unx    31288 b- defN 24-Apr-14 06:54 lazylinop/basicops/pad.py
+-rw-r--r--  2.0 unx     1573 b- defN 24-Apr-14 06:54 lazylinop/basicops/zeros.py
+-rw-r--r--  2.0 unx      264 b- defN 24-Apr-14 06:54 lazylinop/polynomial/__init__.py
+-rw-r--r--  2.0 unx    53006 b- defN 24-Apr-14 06:54 lazylinop/polynomial/polynomial.py
+-rw-r--r--  2.0 unx       78 b- defN 24-Apr-14 06:54 lazylinop/wip/__init__.py
+-rw-r--r--  2.0 unx     1443 b- defN 24-Apr-14 06:54 lazylinop/wip/code_optimization.py
+-rw-r--r--  2.0 unx     1447 b- defN 24-Apr-14 06:54 lazylinop/wip/linear_algebra.py
+-rw-r--r--  2.0 unx   133585 b- defN 24-Apr-14 06:54 lazylinop/wip/signal.py
+-rw-r--r--  2.0 unx    57938 b- defN 24-Apr-14 06:54 lazylinop/wip/special_matrices.py
+-rw-r--r--  2.0 unx       52 b- defN 24-Apr-14 06:54 lazylinop/wip/basicops/__init__.py
+-rw-r--r--  2.0 unx     1607 b- defN 24-Apr-14 06:54 lazylinop/wip/basicops/average.py
+-rw-r--r--  2.0 unx      573 b- defN 24-Apr-14 06:54 lazylinop/wip/basicops/mean.py
+-rw-r--r--  2.0 unx      298 b- defN 24-Apr-14 06:54 lazylinop/wip/linalg/__init__.py
+-rw-r--r--  2.0 unx     4792 b- defN 24-Apr-14 06:54 lazylinop/wip/linalg/coshm.py
+-rw-r--r--  2.0 unx     2816 b- defN 24-Apr-14 06:54 lazylinop/wip/linalg/cosm.py
+-rw-r--r--  2.0 unx     4233 b- defN 24-Apr-14 06:54 lazylinop/wip/linalg/expm.py
+-rw-r--r--  2.0 unx     5587 b- defN 24-Apr-14 06:54 lazylinop/wip/linalg/khatri_rao.py
+-rw-r--r--  2.0 unx     4667 b- defN 24-Apr-14 06:54 lazylinop/wip/linalg/logm.py
+-rw-r--r--  2.0 unx     4694 b- defN 24-Apr-14 06:54 lazylinop/wip/linalg/sinhm.py
+-rw-r--r--  2.0 unx     2823 b- defN 24-Apr-14 06:54 lazylinop/wip/linalg/sinm.py
+-rw-r--r--  2.0 unx     1582 b- defN 24-Apr-14 06:54 lazylinop/wip/linalg/spectral_norm.py
+-rw-r--r--  2.0 unx     3754 b- defN 24-Apr-14 06:54 lazylinop/wip/linalg/sqrtm.py
+-rw-r--r--  2.0 unx      253 b- defN 24-Apr-14 06:54 lazylinop/wip/parallel/__init__.py
+-rw-r--r--  2.0 unx     8328 b- defN 24-Apr-14 06:54 lazylinop/wip/parallel/mpilop.py
+-rw-r--r--  2.0 unx     4897 b- defN 24-Apr-14 06:54 lazylinop/wip/parallel/pmatmat.py
+-rw-r--r--  2.0 unx     4250 b- defN 24-Apr-14 06:54 lazylinop/wip/parallel/pmatmat_mpi.py
+-rw-r--r--  2.0 unx     5902 b- defN 24-Apr-14 06:54 lazylinop/wip/parallel/pmatmat_process.py
+-rw-r--r--  2.0 unx     3306 b- defN 24-Apr-14 06:54 lazylinop/wip/parallel/pmatmat_thread.py
+-rw-r--r--  2.0 unx       23 b- defN 24-Apr-14 06:54 lazylinop/wip/random/__init__.py
+-rw-r--r--  2.0 unx     6721 b- defN 24-Apr-14 06:54 lazylinop/wip/random/rand.py
+-rw-r--r--  2.0 unx     9453 b- defN 24-Apr-14 06:54 lazylinop/wip/signal/slices.py
+-rw-r--r--  2.0 unx     1434 b- defN 24-Apr-14 06:54 lazylinop-1.8.0.dist-info/LICENSE.txt
+-rw-r--r--  2.0 unx     8177 b- defN 24-Apr-14 06:54 lazylinop-1.8.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-14 06:54 lazylinop-1.8.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       10 b- defN 24-Apr-14 06:54 lazylinop-1.8.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     4037 b- defN 24-Apr-14 06:54 lazylinop-1.8.0.dist-info/RECORD
+47 files, 462788 bytes uncompressed, 102437 bytes compressed:  77.9%
```

## zipnote {}

```diff
@@ -33,26 +33,29 @@
 
 Filename: lazylinop/basicops/pad.py
 Comment: 
 
 Filename: lazylinop/basicops/zeros.py
 Comment: 
 
+Filename: lazylinop/polynomial/__init__.py
+Comment: 
+
+Filename: lazylinop/polynomial/polynomial.py
+Comment: 
+
 Filename: lazylinop/wip/__init__.py
 Comment: 
 
 Filename: lazylinop/wip/code_optimization.py
 Comment: 
 
 Filename: lazylinop/wip/linear_algebra.py
 Comment: 
 
-Filename: lazylinop/wip/polynomial.py
-Comment: 
-
 Filename: lazylinop/wip/signal.py
 Comment: 
 
 Filename: lazylinop/wip/special_matrices.py
 Comment: 
 
 Filename: lazylinop/wip/basicops/__init__.py
@@ -114,23 +117,26 @@
 
 Filename: lazylinop/wip/random/__init__.py
 Comment: 
 
 Filename: lazylinop/wip/random/rand.py
 Comment: 
 
-Filename: lazylinop-1.7.1.dist-info/LICENSE.txt
+Filename: lazylinop/wip/signal/slices.py
+Comment: 
+
+Filename: lazylinop-1.8.0.dist-info/LICENSE.txt
 Comment: 
 
-Filename: lazylinop-1.7.1.dist-info/METADATA
+Filename: lazylinop-1.8.0.dist-info/METADATA
 Comment: 
 
-Filename: lazylinop-1.7.1.dist-info/WHEEL
+Filename: lazylinop-1.8.0.dist-info/WHEEL
 Comment: 
 
-Filename: lazylinop-1.7.1.dist-info/top_level.txt
+Filename: lazylinop-1.8.0.dist-info/top_level.txt
 Comment: 
 
-Filename: lazylinop-1.7.1.dist-info/RECORD
+Filename: lazylinop-1.8.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## lazylinop/__init__.py

```diff
@@ -1,5 +1,6 @@
 from .check_op import check_op
 from . import lazylinop
 from .lazylinop import *
 from .basicops import *
-__version__ = '1.7.1'
+from .polynomial import *
+__version__ = '1.8.0'
```

## lazylinop/wip/linalg/cosm.py

```diff
@@ -57,15 +57,15 @@
             raise ValueError("If L is a 2d array, backend must be 'scipy'.")
         return LazyLinOp(
             shape=L.shape,
             matmat=lambda X: sp.linalg.cosm(scale * L) @ X,
             rmatmat=lambda X: sp.linalg.cosm(scale * L.T.conj()) @ X
         )
     elif backend == 'serie':
-        from lazylinop.wip.polynomial import _polyval
+        from lazylinop.polynomial import _polyval
         coefficients = np.empty(nmax + 1, dtype=np.float64)
         factor = 1.0
         sign = 1
         for i in range(nmax + 1):
             if (i % 2) == 0:
                 coefficients[i] = sign * factor
                 sign *= -1
```

## lazylinop/wip/linalg/expm.py

```diff
@@ -92,15 +92,15 @@
             raise ValueError("If L is a 2d array, backend must be 'scipy'.")
         return LazyLinOp(
             shape=L.shape,
             matmat=lambda X: sp.linalg.expm(scale * L) @ X,
             rmatmat=lambda X: sp.linalg.expm(scale * L.T.conj()) @ X
         )
     elif backend == 'serie':
-        from lazylinop.wip.polynomial import _polyval
+        from lazylinop.polynomial import _polyval
         coefficients = np.empty(nmax + 1, dtype=np.float64)
         factor = 1.0
         factorial = 1.0
         for i in range(nmax + 1):
             coefficients[i] = factor / factorial
             factor *= scale
             factorial *= (i + 1)
```

## lazylinop/wip/linalg/sinm.py

```diff
@@ -57,15 +57,15 @@
             raise ValueError("If L is a 2d array, backend must be 'scipy'.")
         return LazyLinOp(
             shape=L.shape,
             matmat=lambda X: sp.linalg.sinm(scale * L) @ X,
             rmatmat=lambda X: sp.linalg.sinm(scale * L.T.conj()) @ X
         )
     elif backend == 'serie':
-        from lazylinop.wip.polynomial import _polyval
+        from lazylinop.polynomial import _polyval
         coefficients = np.empty(nmax + 1, dtype=np.float64)
         factor = 1.0
         sign = 1
         for i in range(nmax + 1):
             if (i % 2) == 1:
                 coefficients[i] = sign * factor
                 sign *= -1
```

## Comparing `lazylinop/wip/polynomial.py` & `lazylinop/polynomial/polynomial.py`

 * *Files 23% similar despite different names*

```diff
@@ -6,46 +6,46 @@
 :py:class:`.LazyLinOp`). This allows to build a :py:class:`.LazyLinOp`
 ``M=p(L)`` when ``p`` is an instance of a polynomial class inherited
 from NumPy polynomial package and matrix representation of
 :py:class:`.LazyLinOp` ``L`` is square.
 
 Below are the provided classes:
 
-    - :py:class:`.Poly` inherited from `NumPy Polynomial <https:/
+    - :py:class:`.Polynomial` inherited from `NumPy Polynomial <https:/
       /numpy.org/doc/stable/reference/generated/
       numpy.polynomial.polynomial.Polynomial.html>`_,
-    - :py:class:`.Cheb`, inherited from `NumPy Chebyshev <https:/
+    - :py:class:`.Chebyshev`, inherited from `NumPy Chebyshev <https:/
       /numpy.org/doc/stable/reference/generated/
       numpy.polynomial.chebyshev.Chebyshev.html>`_,
-    - :py:class:`.Herm`, inherited from `NumPy Hermite <https:/
+    - :py:class:`.Hermite`, inherited from `NumPy Hermite <https:/
       /numpy.org/doc/stable/reference/generated/
       numpy.polynomial.hermite.Hermite.html>`_,
-    - :py:class:`.Herme`, inherited from `NumPy HermiteE <https:/
+    - :py:class:`.HermiteE`, inherited from `NumPy HermiteE <https:/
       /numpy.org/doc/stable/reference/generated/
       numpy.polynomial.hermite_e.HermiteE.html>`_,
-    - :py:class:`.Lag`, inherited from `NumPy Laguerre <https:/
+    - :py:class:`.Laguerre`, inherited from `NumPy Laguerre <https:/
       /numpy.org/doc/stable/reference/generated/
       numpy.polynomial.laguerre.Laguerre.html>`_,
-    - :py:class:`.Leg`, inherited from `NumPy Legendre <https:/
+    - :py:class:`.Legendre`, inherited from `NumPy Legendre <https:/
       /numpy.org/doc/stable/reference/generated/
       numpy.polynomial.legendre.Legendre.html>`_.
 
 Below are the provided functions:
 
     - :py:func:`.xpoly` that returns an instance of a polynomial class
       inherited from NumPy polynomial classes.
       It could be (specified by :py:func:`xpoly(coef, kind=...)`):
 
-      - ``'cheb'`` which is specialized for Chebyshev polynomials.
-      - ``'herm'`` which is specialized for Hermite
+      - ``'chebyshev'`` which is specialized for Chebyshev polynomials.
+      - ``'hermite'`` which is specialized for Hermite
         "physicists" polynomials.
-      - ``'herme'`` which is specialized for Hermite
+      - ``'hermite_e'`` which is specialized for Hermite
         "probabilists" polynomials.
-      - ``'lag'`` which is specialized for Laguerre polynomials.
-      - ``'leg'`` which is specialized for Legendre polynomials.
+      - ``'laguerre'`` which is specialized for Laguerre polynomials.
+      - ``'legendre'`` which is specialized for Legendre polynomials.
       - ``'roots'`` which defines the polynomial from its roots.
     - :py:func:`.power` for the n-th power of any linear operator.
 
 With ``p1`` and ``p2`` two polynomial instances return by
 :py:func:`xpoly(coef1, kind1)` and :py:func:`xpoly(coef2, kind2)`, one can:
 
     - add/substract (if ``kind1=kind2``: ``(p1 + p2)(L)``, ``(p1 - p2)(L)``
@@ -86,17 +86,15 @@
 
    They override the method :py:meth:`__call__` to implement the polynomial
    evaluation and calculate on the fly the available operations.
    Under the hood evaluation is called depending on the polynomial form.
 .. To compute n-th power of a LazyLinOp use :py:func:`power` or
    create :py:class:`Poly` instance such that only n-th coefficient
    is equal to one while the others are equal to zero.
-
 """
-
 import numpy as np
 from numpy.polynomial import Polynomial as P
 from numpy.polynomial import Chebyshev as T
 from numpy.polynomial import Hermite as H
 from numpy.polynomial import HermiteE as HE
 from numpy.polynomial import Laguerre as La
 from numpy.polynomial import Legendre as Le
@@ -110,16 +108,16 @@
     :py:class:`numpy.polynomial.Hermite`,
     :py:class:`numpy.polynomial.HermiteE`,
     :py:class:`numpy.polynomial.Laguerre`
     or :py:class:`numpy.polynomial.Legendre` according to kind.
     ``xpoly`` is the extended function for polynomial creation of any
     kind without using the specialized polynomial classes directly.
     Under the hood, the function create instance depending on the kind
-    :code:`'cheb'`, :code:`'herm'`, :code:`'herme'`,
-    :code:`'lag'`, :code:`'leg'`, :code:`'monomial'` or
+    :code:`'chebyshev'`, :code:`'hermite'`, :code:`'hermite_e'`,
+    :code:`'laguerre'`, :code:`'legendre'`, :code:`'monomial'` or
     :code:`'roots'` of the polynomial you ask for.
     It is pretty simple and you can construct a polynomial as you
     would do with a `NumPy polynomial <https://numpy.org/doc/stable/
     reference/routines.polynomials.classes.html>_`.
 
     Args:
         coef: list or 1d array
@@ -152,17 +150,18 @@
             numpy.polynomial.polynomial.Polynomial>`_ for more details.
         .. symbol: str, optional
             See `NumPy documentation <https://numpy.org/doc/stable/reference/
             generated/numpy.polynomial.polynomial.Polynomial.html#
             numpy.polynomial.polynomial.Polynomial>`_ for more details.
         kind: str, optional
             Representation of the polynomial.
-            It could be 'monomial' (default), 'cheb',
-            'herm' physicists polynomials, 'herme' probabilists polynomials,
-            'lag', 'leg' and 'roots'.
+            It could be 'monomial' (default), 'chebyshev',
+            'hermite' physicists polynomials,
+            'hermite_e' probabilists polynomials, 'laguerre',
+            'legendre' and 'roots'.
             If kind is 'roots', coef is considered to be
             the roots of the polynomial. Leading coefficient is the
             last element :code:`coef[:-1]` of coef argument while the first
             values are the roots of the polynomial.
             Because of the expression :math:`(L - r_0Id)\cdots (L - r_nId)`
             coefficient :math:`c_n` of the highest power :math:`c_nL^n`
             is always 1.
@@ -174,17 +173,17 @@
             coef must be a 1d array.
         ValueError
             kind must be either monomial, cheb, herm,
             herme, lag, leg or roots.
 
     Examples:
         >>> import numpy as np
-        >>> from lazylinop.wip.polynomial import xpoly
-        >>> p1 = xpoly([1.0, 2.0, 1.0], kind='monomial')
-        >>> p2 = xpoly([-1.0, -1.0, 1.0], kind='roots')
+        >>> import lazylinop as lz
+        >>> p1 = lz.polynomial.xpoly([1.0, 2.0, 1.0], kind='monomial')
+        >>> p2 = lz.polynomial.xpoly([-1.0, -1.0, 1.0], kind='roots')
         >>> np.allclose(p1.coef, p2.coef)
         True
 
     .. seealso::
         `numpy.polynomial package
         <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
     """
@@ -192,80 +191,49 @@
         coef = np.asarray(coef)
     if coef.shape[0] < 1:
         raise ValueError("coef size must be > 0.")
     if coef.ndim != 1:
         raise Exception("coef must be a 1d array.")
 
     if kind == 'monomial':
-        return Poly(coef, domain, window, symbol, fromRoots=False)
-    elif kind == 'cheb':
-        return Cheb(coef, domain, window, symbol)
-    elif kind == 'herm':
-        return Herm(coef, domain, window, symbol)
-    elif kind == 'herme':
-        return Herme(coef, domain, window, symbol)
-    elif kind == 'lag':
-        return Lag(coef, domain, window, symbol)
-    elif kind == 'leg':
-        return Leg(coef, domain, window, symbol)
+        return Polynomial(coef, domain, window, symbol, fromRoots=False)
+    elif kind == 'chebyshev':
+        return Chebyshev(coef, domain, window, symbol)
+    elif kind == 'hermite':
+        return Hermite(coef, domain, window, symbol)
+    elif kind == 'hermite_e':
+        return HermiteE(coef, domain, window, symbol)
+    elif kind == 'laguerre':
+        return Laguerre(coef, domain, window, symbol)
+    elif kind == 'legendre':
+        return Legendre(coef, domain, window, symbol)
     elif kind == 'roots':
         if coef.shape[0] == 1:
-            return Poly(coef, domain, window, symbol, fromRoots=False)
+            return Polynomial(coef, domain, window, symbol, fromRoots=False)
         else:
-            return Poly(coef, domain, window, symbol, fromRoots=True)
+            return Polynomial(coef, domain, window, symbol, fromRoots=True)
     else:
-        raise ValueError("kind must be either monomial, cheb," +
-                         " herm, herme, lag, leg or roots.")
+        raise ValueError("kind must be either monomial, chebyshev," +
+                         " hermite, hermite_e," +
+                         " laguerre, legendre or roots.")
 
 
 def _is_lazylinop_poly(p):
-    return isinstance(p, (Poly, Cheb, Herm, Herme, Lag, Leg))
-
-
-def _kind2class(kind: str):
-    """Return class according to kind.
-    It is useful when user converts polynomial
-    from one kind to another.
-
-    Args:
-        kind: str
-            Representation of the polynomial.
-            It could be 'monomial' (default), 'cheb',
-            'herm' physicists polynomials,
-            'herme' probabilists polynomials,
-            'lag', 'leg' and 'roots'.
-
-    Raises:
-        ValueError
-            kind must be either monomial, cheb, herm, herme,
-            lag, leg or roots.
-    """
-    if (
-            kind == 'monomial' or
-            kind == 'cheb' or
-            kind == 'herm' or
-            kind == 'herme' or
-            kind == 'lag' or
-            kind == 'leg' or
-            kind == 'roots'
-    ):
-        return xpoly([1.0, 1.0], kind=kind).__class__
-    else:
-        raise ValueError("kind must be either monomial, cheb," +
-                         " herm, herme, lag, leg or roots.")
+    return isinstance(p, (Polynomial, Chebyshev, Hermite,
+                          HermiteE, Laguerre, Legendre))
 
 
 def _compose(p, op):
     """Returns the composition p(op).
 
     Args:
-        p: :py:class:`.Poly`, :py:class:`.Cheb`, :py:class:`.Herm`,
-        :py:class:`.Herme`, :py:class:`.Lag` or :py:class:`.Leg`
-        op: :py:class:`.Poly`, :py:class:`.Cheb`, :py:class:`.Herm`,
-        :py:class:`.Herme`, :py:class:`.Lag` or :py:class:`.Leg`
+        p: :py:class:`.Poly`, :py:class:`.Chebyshev`, :py:class:`.Hermite`,
+        :py:class:`.HermiteE`, :py:class:`.Laguerre` or :py:class:`.Legendre`
+        op: :py:class:`.Poly`, :py:class:`.Chebyshev`, :py:class:`.Hermite`,
+        :py:class:`.HermiteE`, :py:class:`.Laguerre` or :py:class:`.Legendre`
 
     Raises:
         TypeError: op or p is not of a valid lazylinop polynomial class.
 
     .. seealso::
         `numpy.polynomial package
         <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
@@ -277,20 +245,20 @@
         tmp = op.__class__.__bases__[0].__call__(p, op)  # np polynomial
         # then convert to lazylinop poly
         return op.__class__(tmp.coef, domain=tmp.domain, window=tmp.window)
     else:
         raise TypeError('op is not valid lazylinop polynomial')
 
 
-class Poly(P):
+class Polynomial(P):
     """This class implements a polynomial class derived from
     :py:class:`numpy.polynomial.Polynomial` and so relies on NumPy polynomial
     package to manipulate polynomials.
 
-    See :py:mod:`lazylinop.wip.polynomial` for an introduction to implemented
+    See :py:mod:`lazylinop.polynomial` for an introduction to implemented
     operations and their basic use.
     """
 
     def __init__(self, coef, domain: list = [-1.0, 1.0],
                  window: list = [-1.0, 1.0], symbol: str = 'x',
                  fromRoots: bool = False):
         r"""__init__(self, coef, fromRoots: bool = False)
@@ -339,24 +307,24 @@
                 numpy.polynomial.polynomial.Polynomial>`_ for more details.
             .. symbol: str, optional
                 See `NumPy documentation <https://numpy.org/doc/
                 stable/reference/generated/
                 numpy.polynomial.polynomial.Polynomial.html#
                 numpy.polynomial.polynomial.Polynomial>`_ for more details.
             fromRoots: bool, optional
-                - If False uses polynomial coefficients.
-                - If True uses polynomial roots.
+                - If ``False`` uses polynomial coefficients.
+                - If ``True`` uses polynomial roots.
                   Last element :code:`coef[-1]` of :code:`coef`
                   is the leading coefficient.
 
         Examples:
             >>> import numpy as np
-            >>> from lazylinop.wip.polynomial import Poly
-            >>> p1 = Poly([1.0, 2.0, 1.0], fromRoots=False)
-            >>> p2 = Poly([-1.0, -1.0, 1.0], fromRoots=True)
+            >>> import lazylinop as lz
+            >>> p1 = lz.polynomial.Polynomial([1, 2, 1], fromRoots=False)
+            >>> p2 = lz.polynomial.Polynomial([-1, -1, 1], fromRoots=True)
             >>> np.allclose(p1.coef, p2.coef)
             True
 
         .. seealso::
             `numpy.polynomial package
             <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
         """
@@ -395,18 +363,18 @@
             :py:class:`numpy.polynomial.Legendre` instance
 
         Raises:
             TypeError
                 Unexpected op.
 
         Examples:
-            >>> from lazylinop import eye, islazylinop
-            >>> from lazylinop.wip.polynomial import Poly
-            >>> p = Poly([1.0, 2.0, 3.0])
-            >>> L = eye(3, n=3, k=0)
+            >>> import numpy as np
+            >>> import lazylinop as lz
+            >>> p = lz.polynomial.Polynomial([1.0, 2.0, 3.0])
+            >>> L = lz.eye(3, n=3, k=0)
             >>> islazylinop(p(L))
             True
             >>> x = np.random.randn(3)
             >>> np.allclose(6.0 * x, p(L) @ x)
             True
 
         .. seealso::
@@ -420,26 +388,26 @@
                 return self.leading_coef * _polyvalfromroots(op, self.roots)
         elif _is_lazylinop_poly(op):
             return _compose(self, op)
         else:
             raise TypeError('Unexpected op.')
 
 
-class Cheb(T):
+class Chebyshev(T):
     """This class implements a Chebyshev polynomial class derived from
     :py:class:`numpy.polynomial.Chebyshev` and so relies on NumPy polynomial
     package to manipulate polynomials.
 
-    See :py:mod:`lazylinop.wip.polynomial` for an introduction to implemented
+    See :py:mod:`lazylinop.polynomial` for an introduction to implemented
     operations and their basic use.
     """
 
     def __init__(self, coef, domain: list = [-1.0, 1.0],
                  window: list = [-1.0, 1.0], symbol: str = 'x'):
-        r"""Init instance of Cheb.
+        r"""Init instance of Chebyshev.
 
         Args:
             coef: list
                 List of Chebyshev
                 coefficients :math:`\lbrack c_0,c_1,\cdots,c_n\rbrack`.
                 Polynomial of :py:class:`.LazyLinOp` ``L`` is:
 
@@ -462,16 +430,16 @@
             .. symbol: str, optional
                 See `NumPy documentation <https://numpy.org/doc/
                 stable/reference/generated/
                 numpy.polynomial.chebyshev.Chebyshev.html#
                 numpy.polynomial.chebyshev.Chebyshev>`_ for more details.
 
         Examples:
-            >>> from lazylinop.wip.polynomial import Cheb
-            >>> t = Cheb([1.0, 2.0, 3.0])
+            >>> from lazylinop.polynomial import Chebyshev
+            >>> t = Chebyshev([1.0, 2.0, 3.0])
             >>> (t + t).coef
             array([2., 4., 6.])
 
         .. seealso::
             `numpy.polynomial package
             <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
         """
@@ -496,16 +464,16 @@
             :py:class:`numpy.polynomial.Laguerre` or
             :py:class:`numpy.polynomial.Legendre` instance
 
         Raises:
 
         Examples:
             >>> from lazylinop import eye, islazylinop
-            >>> from lazylinop.wip.polynomial import Cheb
-            >>> t = Cheb([1.0, 2.0, 3.0])
+            >>> from lazylinop.polynomial import Chebyshev
+            >>> t = Chebyshev([1.0, 2.0, 3.0])
             >>> L = eye(3, n=3, k=0)
             >>> islazylinop(t(L))
             True
 
         .. seealso::
             `numpy.polynomial package
             <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
@@ -514,26 +482,26 @@
             return _chebval(op, self.coef)
         elif _is_lazylinop_poly(op):
             return _compose(self, op)
         else:
             raise TypeError('Unexpected op.')
 
 
-class Herm(H):
+class Hermite(H):
     """This class implements a Hermite "physicist" polynomial class derived
     from :py:class:`numpy.polynomial.Hermite` and so relies on NumPy polynomial
     package to manipulate polynomials.
 
-    See :py:mod:`lazylinop.wip.polynomial` for an introduction to implemented
+    See :py:mod:`lazylinop.polynomial` for an introduction to implemented
     operations and their basic use.
     """
 
     def __init__(self, coef, domain: list = [-1.0, 1.0],
                  window: list = [-1.0, 1.0], symbol: str = 'x'):
-        r"""Init instance of Herm.
+        r"""Init instance of Hermite.
 
         Args:
             coef: list
                 List of Hermite coefficients
                 :math:`\lbrack c_0,c_1,\cdots,c_n\rbrack`.
                 Polynomial of :py:class:`.LazyLinOp` ``L`` is:
 
@@ -556,16 +524,16 @@
             .. symbol: str, optional
                 See `NumPy documentation <https://numpy.org/doc/
                 stable/reference/generated/
                 numpy.polynomial.hermite.Hermite.html#
                 numpy.polynomial.hermite.Hermite>`_ for more details.
 
         Examples:
-            >>> from lazylinop.wip.polynomial import Herm
-            >>> h = Herm([1.0, 2.0, 3.0])
+            >>> from lazylinop.polynomial import Hermite
+            >>> h = Hermite([1.0, 2.0, 3.0])
             >>> (h + h).coef
             array([2., 4., 6.])
 
         .. seealso::
             `numpy.polynomial package
             <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
         """
@@ -591,16 +559,16 @@
             :py:class:`numpy.polynomial.Laguerre` or
             :py:class:`numpy.polynomial.Legendre` instance
 
         Raises:
 
         Examples:
             >>> from lazylinop import eye, islazylinop
-            >>> from lazylinop.wip.polynomial import Herm
-            >>> h = Herm([1.0, 2.0, 3.0])
+            >>> from lazylinop.polynomial import Hermite
+            >>> h = Hermite([1.0, 2.0, 3.0])
             >>> L = eye(3, n=3, k=0)
             >>> islazylinop(h(L))
             True
 
         .. seealso::
             `numpy.polynomial package
             <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
@@ -609,26 +577,26 @@
             return _hermval(op, self.coef)
         elif _is_lazylinop_poly(op):
             return _compose(self, op)
         else:
             raise TypeError('Unexpected op.')
 
 
-class Herme(HE):
+class HermiteE(HE):
     """This class implements a Hermite "probabilist" polynomial class derived
     from :py:class:`numpy.polynomial.HermiteE` and so relies on NumPy
     polynomial package to manipulate polynomials.
 
-    See :py:mod:`lazylinop.wip.polynomial` for an introduction to implemented
+    See :py:mod:`lazylinop.polynomial` for an introduction to implemented
     operations and their basic use.
     """
 
     def __init__(self, coef, domain: list = [-1.0, 1.0],
                  window: list = [-1.0, 1.0], symbol: str = 'x'):
-        r"""Init instance of Herme.
+        r"""Init instance of HermiteE.
 
         Args:
             coef: list
                 List of Hermite coefficients
                 :math:`\lbrack c_0,c_1,\cdots,c_n\rbrack`.
                 Polynomial of :py:class:`.LazyLinOp` ``L`` is:
 
@@ -652,16 +620,16 @@
                 See `NumPy documentation <https://numpy.org/doc/
                 stable/reference/generated/
                 numpy.polynomial.hermite_e.HermiteE.html#
                 numpy.polynomial.hermite_e.HermiteE>`_ for more details.
 
         Examples:
             >>> from lazylinop import eye, islazylinop
-            >>> from lazylinop.wip.polynomial import Herme
-            >>> h = Herme([1.0, 2.0, 3.0])
+            >>> from lazylinop.polynomial import HermiteE
+            >>> h = HermiteE([1.0, 2.0, 3.0])
             >>> (h + h).coef
             array([2., 4., 6.])
 
         .. seealso::
             `numpy.polynomial package
             <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
         """
@@ -686,16 +654,16 @@
             :py:class:`numpy.polynomial.Laguerre` or
             :py:class:`numpy.polynomial.Legendre` instance
 
         Raises:
 
         Examples:
             >>> from lazylinop import eye, islazylinop
-            >>> from lazylinop.wip.polynomial import herme
-            >>> h = herme([1.0, 2.0, 3.0])
+            >>> from lazylinop.polynomial import HermiteE
+            >>> h = HermiteE([1.0, 2.0, 3.0])
             >>> L = eye(3, n=3, k=0)
             >>> islazylinop(h(L))
             True
 
         .. seealso::
             `numpy.polynomial package
             <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
@@ -704,26 +672,26 @@
             return _hermval(op, self.coef, False)
         elif _is_lazylinop_poly(op):
             return _compose(self, op)
         else:
             raise TypeError('Unexpected op.')
 
 
-class Lag(La):
+class Laguerre(La):
     """This class implements a Laguerre polynomial class derived from
     :py:class:`numpy.polynomial.Laguerre` and so relies on NumPy polynomial
     package to manipulate polynomials.
 
-    See :py:mod:`lazylinop.wip.polynomial` for an introduction to implemented
+    See :py:mod:`lazylinop.polynomial` for an introduction to implemented
     operations and their basic use.
     """
 
     def __init__(self, coef, domain: list = [-1.0, 1.0],
                  window: list = [-1.0, 1.0], symbol: str = 'x'):
-        r"""Init instance of Lag.
+        r"""Init instance of Laguerre.
 
         Args:
             coef: list
                 List of Laguerre coefficients
                 :math:`\lbrack c_0,c_1,\cdots,c_n\rbrack`.
                 Polynomial of :py:class:`.LazyLinOp` ``L`` is:
 
@@ -747,16 +715,16 @@
                 See `NumPy documentation <https://numpy.org/doc/
                 stable/reference/generated/
                 numpy.polynomial.laguerre.Laguerre.html#
                 numpy.polynomial.laguerre.Laguerre>`_ for more details.
 
         Examples:
             >>> from lazylinop import eye, islazylinop
-            >>> from lazylinop.wip.polynomial import Lag
-            >>> la = Lag([1.0, 2.0, 3.0])
+            >>> from lazylinop.polynomial import Laguerre
+            >>> la = Laguerre([1.0, 2.0, 3.0])
             >>> (la + la).coef
             array([2., 4., 6.])
             >>> L = eye(3, n=3, k=0)
             >>> islazylinop(la(L))
             True
 
         .. seealso::
@@ -784,16 +752,16 @@
             :py:class:`numpy.polynomial.Laguerre` or
             :py:class:`numpy.polynomial.Legendre` instance
 
         Raises:
 
         Examples:
             >>> from lazylinop import eye, islazylinop
-            >>> from lazylinop.wip.polynomial import Lag
-            >>> la = Lag([1.0, 2.0, 3.0])
+            >>> from lazylinop.polynomial import Laguerre
+            >>> la = Laguerre([1.0, 2.0, 3.0])
             >>> L = eye(3, n=3, k=0)
             >>> islazylinop(la(L))
             True
 
         .. seealso::
             `numpy.polynomial package
             <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
@@ -802,26 +770,26 @@
             return _lagval(op, self.coef)
         elif _is_lazylinop_poly(op):
             return _compose(self, op)
         else:
             raise TypeError('Unexpected op.')
 
 
-class Leg(Le):
+class Legendre(Le):
     """This class implements a Legendre polynomial class derived from
     :py:class:`numpy.polynomial.Legendre` and so relies on NumPy polynomial
     package to manipulate polynomials.
 
-    See :py:mod:`lazylinop.wip.polynomial` for an introduction to implemented
+    See :py:mod:`lazylinop.polynomial` for an introduction to implemented
     operations and their basic use.
     """
 
     def __init__(self, coef, domain: list = [-1.0, 1.0],
                  window: list = [-1.0, 1.0], symbol: str = 'x'):
-        r"""Init instance of Leg.
+        r"""Init instance of Legendre.
 
         Args:
             coef: list
                 List of Legendre coefficients
                 :math:`\lbrack c_0,c_1,\cdots,c_n\rbrack`.
                 Polynomial of :py:class:`.LazyLinOp` ``L`` is:
 
@@ -845,16 +813,16 @@
                 See `NumPy documentation <https://numpy.org/doc/
                 stable/reference/generated/
                 numpy.polynomial.legendre.Legendre.html#
                 numpy.polynomial.legendre.Legendre>`_ for more details.
 
         Examples:
             >>> from lazylinop import eye, islazylinop
-            >>> from lazylinop.wip.polynomial import Leg
-            >>> le = Leg([1.0, 2.0, 3.0])
+            >>> from lazylinop.polynomial import Legendre
+            >>> le = Legendre([1.0, 2.0, 3.0])
             >>> (le + le).coef
             array([2., 4., 6.])
             >>> L = eye(3, n=3, k=0)
             >>> islazylinop(le(L))
             True
 
         .. seealso::
@@ -883,16 +851,16 @@
             :py:class:`numpy.polynomial.Laguerre` or
             :py:class:`numpy.polynomial.Legendre` instance
 
         Raises:
 
         Examples:
             >>> from lazylinop import eye, islazylinop
-            >>> from lazylinop.wip.polynomial import Leg
-            >>> le = Leg([1.0, 2.0, 3.0])
+            >>> from lazylinop.polynomial import Legendre
+            >>> le = Legendre([1.0, 2.0, 3.0])
             >>> L = eye(3, n=3, k=0)
             >>> islazylinop(le(L))
             True
 
         .. seealso::
             `numpy.polynomial package
             <https://numpy.org/doc/stable/reference/routines.polynomials.html>`_.
@@ -907,14 +875,16 @@
 
 def _polyval(L, c):
     r"""Constructs a :py:class:`.LazyLinOp` polynomial ``P(L)`` of linear
     operator ``L``.
 
     ``P(L)`` is equal to :math:`c_0Id+c_1L^1+\cdots +c_nL^n`.
 
+    The Horner's method is used to compute ``P(L) @ X``.
+
     ``Y = P(L) @ X`` shape is ``(L.shape[0], X.shape[1])``.
 
     Args:
         L: LazyLinOp
             Linear operator (matrix representation must be square).
         c: 1d array
             List of polynomial coefficients.
@@ -930,19 +900,18 @@
         Exception
             List of coefficients has zero size.
         Exception
             coef must be a 1d array.
 
     Examples:
         >>> import numpy as np
-        >>> from lazylinop import eye
-        >>> from lazylinop.wip.polynomial import polyval
+        >>> import lazylinop as lz
         >>> x = np.random.randn(3)
-        >>> L = eye(3, n=3, k=0)
-        >>> y = polyval(L, [1.0, 2.0, 3.0]) @ x
+        >>> L = lz.eye(3, n=3, k=0)
+        >>> y = lz.polynomial._polyval(L, [1.0, 2.0, 3.0]) @ x
         >>> np.allclose(6.0 * x, y)
         True
 
     .. seealso::
         - `NumPy polynomial class <https://docs.scipy.org/doc//numpy-1.9.3/
           reference/generated/numpy.polynomial.polynomial.polyval.html>`_.
         - :py:func:`polyvalfromroots`.
@@ -952,16 +921,15 @@
         raise Exception("Matrix representation of L is not square.")
 
     c = np.asarray(c)
 
     if c.ndim != 1:
         raise Exception("coef must be a 1d array.")
 
-    D = c.shape[0]
-    if D == 0:
+    if c.shape[0] == 0:
         raise Exception("List of coefficients has zero size.")
 
     def _matmat(L, x, c):
         # x can't be a LazyLinOp here because it's handle before in
         # LazyLinOp.__matmul__
         if x.ndim == 1:
             x1d = True
@@ -1009,19 +977,18 @@
         Exception
             List of roots has zero size.
         Exception
             roots must be a 1d array.
 
     Examples:
         >>> import numpy as np
-        >>> from lazylinop import eye
-        >>> from lazylinop.wip.polynomial import _polyvalfromroots
+        >>> import lazylinop as lz
         >>> x = np.random.randn(3)
-        >>> L = eye(3, n=3, k=0)
-        >>> y = _polyvalfromroots(L, [1.0, 1.0, 1.0]) @ x
+        >>> L = lz.eye(3, n=3, k=0)
+        >>> y = lz.polynomial._polyvalfromroots(L, [1.0, 1.0, 1.0]) @ x
         >>> np.allclose(0.0 * x, y)
         True
 
     .. seealso::
         - `NumPy polyvalfromroots <https://docs.scipy.org/doc/
           numpy-1.9.3/reference/generated/numpy.polynomial.polynomial.
           polyvalfromroots.html>`_.
@@ -1101,19 +1068,18 @@
         Exception
             List of coefficients has zero size.
         Exception
             coef must be a 1d array.
 
     Examples:
         >>> import numpy as np
-        >>> from lazylinop import eye
-        >>> from lazylinop.wip.polynomial import _chebval
+        >>> import lazylinop as lz
         >>> x = np.random.randn(3)
-        >>> L = eye(3, n=3, k=0)
-        >>> y = _chebval(L, [1.0, 2.0, 3.0]) @ x
+        >>> L = lz.eye(3, n=3, k=0)
+        >>> y = lz.polynomial._chebval(L, [1.0, 2.0, 3.0]) @ x
         >>> np.allclose(6.0 * x, y)
         True
 
     .. seealso::
         - `Wikipedia <https://en.wikipedia.org/wiki/Chebyshev_polynomials>`_,
         - `Polynomial magic web page
           <https://francisbach.com/chebyshev-polynomials/>`_,
@@ -1122,16 +1088,15 @@
     """
 
     if L.shape[0] != L.shape[1]:
         raise Exception("Matrix representation of L is not square.")
 
     c = np.asarray(c)
 
-    D = c.shape[0]
-    if D == 0:
+    if c.shape[0] == 0:
         raise Exception("List of coefficients has zero size.")
 
     if c.ndim != 1:
         raise Exception("coef must be a 1d array.")
 
     clenshaw_funcs = [lambda k, L, bk: L @ (2 * bk),  # alpha(k)
                       lambda k: 1,  # beta(k)
@@ -1179,35 +1144,34 @@
         L: LazyLinOp
             Linear operator (matrix representation must be square).
         c: 1d array
             List of Hermite (physicist) polynomial(s) coefficients.
             If the size of the 1d array is n + 1 then the largest power of the
             polynomial is n.
         physicist: bool, optional
-            If True (default) construct Hermite "physicist" polynomial.
-            If False construct Hermite "probabilistic" polynomial.
+            If ``True`` (default) construct Hermite "physicist" polynomial.
+            If ``False`` construct Hermite "probabilistic" polynomial.
 
     Returns:
         LazyLinOp
 
     Raises:
         Exception
             Matrix representation of L is not square.
         Exception
             List of coefficients has zero size.
         Exception
             coef must be a 1d array.
 
     Examples:
         >>> import numpy as np
-        >>> from lazylinop import eye
-        >>> from lazylinop.wip.polynomial import _hermval
+        >>> import lazylinop as lz
         >>> x = np.array([1.0, 0.0, 0.0])
-        >>> L = eye(3, n=3, k=0)
-        >>> y = _hermval(L, [1.0, 2.0, 3.0]) @ x
+        >>> L = lz.eye(3, n=3, k=0)
+        >>> y = lz.polynomial._hermval(L, [1.0, 2.0, 3.0]) @ x
         >>> z = np.polynomial.hermite.hermval(x[0], [1.0, 2.0, 3.0])
         >>> np.allclose(y[0], z)
         True
 
     .. seealso::
         - `Wikipedia <https://en.wikipedia.org/wiki/Hermite_polynomials>`_,
         - `NumPy polynomial class <https://docs.scipy.org/doc//numpy-1.9.3/
@@ -1215,16 +1179,15 @@
     """
 
     if L.shape[0] != L.shape[1]:
         raise Exception("Matrix representation of L is not square.")
 
     c = np.asarray(c)
 
-    D = c.shape[0]
-    if D == 0:
+    if c.shape[0] == 0:
         raise Exception("List of coefficients has zero size.")
 
     if c.ndim != 1:
         raise Exception("coef must be a 1d array.")
 
     if physicist:
         clenshaw_funcs = [
@@ -1284,19 +1247,18 @@
         Exception
             List of coefficients has zero size.
         Exception
             coef must be a 1d array.
 
     Examples:
         >>> import numpy as np
-        >>> from lazylinop import eye
-        >>> from lazylinop.wip.polynomial import _lagval
+        >>> import lazylinop as lz
         >>> x = np.array([1.0, 0.0, 0.0])
-        >>> L = eye(3, n=3, k=0)
-        >>> y = _lagval(L, [1.0, 2.0, 3.0]) @ x
+        >>> L = lz.eye(3, n=3, k=0)
+        >>> y = lz.polynomial._lagval(L, [1.0, 2.0, 3.0]) @ x
         >>> z = np.polynomial.laguerre.lagval(x[0], [1.0, 2.0, 3.0])
         >>> np.allclose(y[0], z)
         True
 
     .. seealso::
         - `Wikipedia <https://en.wikipedia.org/wiki/Laguerre_polynomials>`_,
         - `NumPy polynomial class <https://docs.scipy.org/doc//numpy-1.9.3/
@@ -1307,16 +1269,15 @@
         raise Exception("Matrix representation of L is not square.")
 
     c = np.asarray(c)
 
     if c.ndim != 1:
         raise Exception("coef must be a 1d array.")
 
-    D = c.shape[0]
-    if D == 0:
+    if c.shape[0] == 0:
         raise Exception("List of coefficients has zero size.")
 
     clenshaw_funcs = [
         lambda k, L, bk: ((2 * k + 1) * bk - L @ bk) / (k + 1),  # alpha(k)
         lambda k: k / (k + 1),  # beta(k)
         lambda L, bk: bk - L @ bk  # phi1(L)
                      ]
@@ -1366,20 +1327,19 @@
         Exception
             List of coefficients has zero size.
         Exception
             coef must be a 1d array.
 
     Examples:
         >>> import numpy as np
-        >>> from lazylinop import eye
-        >>> from lazylinop.wip.polynomial import _legval
-        >>> x = np.random.randn(3)
-        >>> L = eye(3, n=3, k=0)
-        >>> y = _legval(L, [1.0, 2.0, 3.0]) @ x
-        >>> z = np.polynomial.laguerre.legval(x[0], [1.0, 2.0, 3.0])
+        >>> import lazylinop as lz
+        >>> x = np.array([1.0, 0.0, 0.0])
+        >>> L = lz.eye(3, n=3, k=0)
+        >>> y = lz.polynomial._legval(L, [1.0, 2.0, 3.0]) @ x
+        >>> z = np.polynomial.legendre.legval(x[0], [1.0, 2.0, 3.0])
         >>> np.allclose(y[0], z)
         True
 
     .. seealso::
         - `Wikipedia <https://en.wikipedia.org/wiki/Legendre_polynomials>`_,
         - `NumPy polynomial class <https://docs.scipy.org/doc//numpy-1.9.3/
           reference/generated/numpy.polynomial.legendre.legval.html>`_.
@@ -1389,21 +1349,20 @@
         raise Exception("Matrix representation of L is not square.")
 
     c = np.asarray(c)
 
     if c.ndim != 1:
         raise Exception("coef must be a 1d array.")
 
-    D = c.shape[0]
-    if D == 0:
+    if c.shape[0] == 0:
         raise Exception("List of coefficients has zero size.")
 
     clenshaw_funcs = [
         lambda k, L, bk: L @ ((2 * k + 1) / (k + 1) * bk),  # alpha(k)
-        lambda k:  k / (k + 1),  # beta(k)
+        lambda k: k / (k + 1),  # beta(k)
         lambda L, bk: L @ bk  # phi1(L)
     ]
 
     return LazyLinOp(
         shape=L.shape,
         matmat=lambda x: _matmat_clenshaw(L, c, x, *clenshaw_funcs),
         rmatmat=lambda x: _matmat_clenshaw(L.T.conj(), c, x, *clenshaw_funcs)
@@ -1461,471 +1420,14 @@
             b1 = bk
         # phi0 is always 1/Id
         y = c[0] * x + phi1_func(L, b1) - (
             (beta_func(1) * b2) if beta_func(1) != 1 else b2)
         return y.ravel() if is_1d else y
 
 
-def _rchebval(L, c):
-    r"""Constructs a :py:class:`.LazyLinOp` Chebysev polynomial ``P(L)`` of
-    linear operator ``L``.
-
-    ``P(L)`` is equal to :math:`c_0Id+c_1T_1(L)+\cdots +c_nT_n(L)`.
-
-    The k-th Chebyshev polynomial can be computed by recurrence:
-
-    .. math::
-
-        \begin{eqnarray}
-        T_0(L) &=& 1\\
-        T_1(L) &=& L\\
-        T_{k+1}(L) &=& 2LT_k(L) - T_{k-1}(L)
-        \end{eqnarray}
-
-    ``Y = P(L) @ X`` shape is ``(L.shape[0], X.shape[1])``.
-
-
-    Args:
-        L: LazyLinOp
-            Linear operator (matrix representation must be square).
-        c: 1d array
-            List of Chebyshev polynomial(s) coefficients.
-            If the size of the 1d array is n + 1 then the largest power of the
-            polynomial is n.
-
-    Returns:
-        LazyLinOp
-
-    Raises:
-        Exception
-            Matrix representation of L is not square.
-        Exception
-            List of coefficients has zero size.
-        Exception
-            coef must be a 1d array.
-
-    Examples:
-        >>> import numpy as np
-        >>> from lazylinop import eye
-        >>> from lazylinop.wip.polynomial import _rchebval
-        >>> x = np.random.randn(3)
-        >>> L = eye(3, n=3, k=0)
-        >>> y = _rchebval(L, [1.0, 2.0, 3.0]) @ x
-        >>> np.allclose(6.0 * x, y)
-        True
-
-    .. seealso::
-        - `Wikipedia <https://en.wikipedia.org/wiki/Chebyshev_polynomials>`_,
-        - `Polynomial magic web page
-          <https://francisbach.com/chebyshev-polynomials/>`_,
-        - `NumPy polynomial class <https://docs.scipy.org/doc//numpy-1.9.3/
-          reference/generated/numpy.polynomial.chebyshev.chebval.html>`_.
-    """
-
-    if L.shape[0] != L.shape[1]:
-        raise Exception("Matrix representation of L is not square.")
-
-    c = np.asarray(c)
-
-    D = c.shape[0]
-    if D == 0:
-        raise Exception("List of coefficients has zero size.")
-
-    if c.ndim != 1:
-        raise Exception("coef must be a 1d array.")
-
-    def _matmat(L, x, c):
-        if x.ndim == 1:
-            is_1d = True
-            x = x.reshape(x.shape[0], 1)
-        else:
-            is_1d = False
-        batch_size = x.shape[1]
-        T0x = np.copy(x)
-        T1x = np.empty((L.shape[0], batch_size),
-                       dtype=binary_dtype(c.dtype, x.dtype))
-        T2x = np.empty((L.shape[0], batch_size),
-                       dtype=binary_dtype(c.dtype, x.dtype))
-        output = np.multiply(c[0], T0x)
-        if D > 1:
-            # loop over the coefficients
-            for i in range(1, D):
-                if i == 1:
-                    np.copyto(T1x, L @ x)
-                    if c[i] != 0.0:
-                        np.add(output, np.multiply(c[i], T1x), out=output)
-                else:
-                    np.copyto(T2x, np.subtract(np.multiply(2.0, L @ T1x), T0x))
-                    # Recurrence
-                    np.copyto(T0x, T1x)
-                    np.copyto(T1x, T2x)
-                    if c[i] != 0.0:
-                        np.add(output, np.multiply(c[i], T2x), out=output)
-        return output.ravel() if is_1d else output
-
-    return LazyLinOp(
-        shape=L.shape,
-        matmat=lambda x: _matmat(L, x, c),
-        rmatmat=lambda x: _matmat(L.T.conj(), x, c)
-    )
-
-
-def _rhermval(L, c, physicist: bool = True):
-    r"""Constructs a :py:class:`.LazyLinOp` Hermite (physicist or
-    probabilistic) polynomial ``P(L)`` of linear operator ``L``.
-
-    ``P(L)`` is equal to :math:`c_0Id+c_1H_1(L)+\cdots +c_nH_n(L)`.
-
-    The k-th Hermite (physicist) polynomial can be computed by recurrence:
-
-    .. math::
-
-        \begin{eqnarray}
-        H_0(L) &=& Id\\
-        H_1(L) &=& 2L\\
-        H_{k+1}(L) &=& 2LH_k(L) - 2kH_{k-1}(L)
-        \end{eqnarray}
-
-    The k-th Hermite (probabilist) polynomial can be computed by recurrence:
-
-    .. math::
-
-        \begin{eqnarray}
-        H_0(L) &=& Id\\
-        H_1(L) &=& L\\
-        H_{k+1}(L) &=& LH_k(L) - kH_{k-1}(L)
-        \end{eqnarray}
-
-    ``Y = P(L) @ X`` shape is ``(L.shape[0], X.shape[1])``.
-
-
-    Args:
-        L: LazyLinOp
-            Linear operator (matrix representation must be square).
-        c: 1d array
-            List of Hermite (physicist) polynomial(s) coefficients.
-            If the size of the 1d array is n + 1 then the largest power of the
-            polynomial is n.
-        physicist: bool, optional
-            If True (default) construct Hermite "physicist" polynomial.
-            If False construct Hermite "probabilistic" polynomial.
-
-    Returns:
-        LazyLinOp
-
-    Raises:
-        Exception
-            Matrix representation of L is not square.
-        Exception
-            List of coefficients has zero size.
-        Exception
-            coef must be a 1d array.
-
-    Examples:
-        >>> import numpy as np
-        >>> from lazylinop import eye
-        >>> from lazylinop.wip.polynomial import _hermval
-        >>> x = np.array([1.0, 0.0, 0.0])
-        >>> L = eye(3, n=3, k=0)
-        >>> y = _hermval(L, [1.0, 2.0, 3.0]) @ x
-        >>> z = np.polynomial.hermite.hermval(x[0], [1.0, 2.0, 3.0])
-        >>> np.allclose(y[0], z)
-        True
-
-    .. seealso::
-        - `Wikipedia <https://en.wikipedia.org/wiki/Hermite_polynomials>`_,
-        - `NumPy polynomial class <https://docs.scipy.org/doc//numpy-1.9.3/
-          reference/generated/numpy.polynomial.hermite.hermval.html>`_.
-    """
-
-    if L.shape[0] != L.shape[1]:
-        raise Exception("Matrix representation of L is not square.")
-
-    c = np.asarray(c)
-
-    D = c.shape[0]
-    if D == 0:
-        raise Exception("List of coefficients has zero size.")
-
-    if c.ndim != 1:
-        raise Exception("coef must be a 1d array.")
-
-    def _matmat(L, x, c):
-        if x.ndim == 1:
-            is_1d = True
-            x = x.reshape(x.shape[0], 1)
-        else:
-            is_1d = False
-        batch_size = x.shape[1]
-        H0x = np.empty((L.shape[0], batch_size),
-                       dtype=binary_dtype(c.dtype, x.dtype))
-        H1x = np.empty((L.shape[0], batch_size),
-                       dtype=binary_dtype(c.dtype, x.dtype))
-        H2x = np.empty((L.shape[0], batch_size),
-                       dtype=binary_dtype(c.dtype, x.dtype))
-        np.copyto(H0x, x)
-        output = np.multiply(c[0], H0x)
-        if D > 1:
-            # loop over the coefficients
-            if physicist:
-                for i in range(1, D):
-                    if i == 1:
-                        np.copyto(H1x, np.multiply(2.0, L @ x))
-                        if c[i] != 0.0:
-                            np.add(output, np.multiply(c[i], H1x), out=output)
-                    else:
-                        np.copyto(H2x,
-                                  np.subtract(np.multiply(2.0, L @ H1x),
-                                              np.multiply(2 * (i - 1), H0x)))
-                        # Recurrence
-                        np.copyto(H0x, H1x)
-                        np.copyto(H1x, H2x)
-                        if c[i] != 0.0:
-                            np.add(output, np.multiply(c[i], H2x), out=output)
-            else:
-                for i in range(1, D):
-                    if i == 1:
-                        np.copyto(H1x, L @ x)
-                        if c[i] != 0.0:
-                            np.add(output, np.multiply(c[i], H1x), out=output)
-                    else:
-                        np.copyto(H2x, np.subtract(L @ H1x,
-                                                   np.multiply(i - 1, H0x)))
-                        # Recurrence
-                        np.copyto(H0x, H1x)
-                        np.copyto(H1x, H2x)
-                        if c[i] != 0.0:
-                            np.add(output, np.multiply(c[i], H2x), out=output)
-        return output.ravel() if is_1d else output
-
-    return LazyLinOp(
-        shape=L.shape,
-        matmat=lambda x: _matmat(L, x, c),
-        rmatmat=lambda x: _matmat(L.T.conj(), x, c)
-    )
-
-
-def _rlagval(L, c):
-    r"""Constructs a :py:class:`.LazyLinOp` Laguerre polynomial ``P(L)``
-    of linear operator ``L``.
-
-    ``P(L)`` is equal to :math:`c_0Id+c_1L_{a,1}(L)+\cdots+c_nL_{a,n}(L)`.
-
-    The k-th Laguerre polynomial can be computed by recurrence:
-
-    .. math::
-
-        \begin{eqnarray}
-        L_{a,0}(L) &=& Id\\
-        L_{a,1}(L) &=& Id - L\\
-        L_{a,k+1}(L) &=& \frac{(2k + 1 - L)L_{a,k}(L) - kL_{a,k-1}(L)}{k + 1}
-        \end{eqnarray}
-
-    ``Y = P(L) @ X`` shape is ``(L.shape[0], X.shape[1])``.
-
-
-    Args:
-        L: LazyLinOp
-            Linear operator (matrix representation must be square).
-        c: 1d array
-            List of Laguerre polynomial(s) coefficients.
-            If the size of the 1d array is n + 1 then the largest power
-            of the polynomial is n.
-
-    Returns:
-        LazyLinOp
-
-    Raises:
-        Exception
-            Matrix representation of L is not square.
-        Exception
-            List of coefficients has zero size.
-        Exception
-            coef must be a 1d array.
-
-    Examples:
-        >>> import numpy as np
-        >>> from lazylinop import eye
-        >>> from lazylinop.wip.polynomial import _rlagval
-        >>> x = np.array([1.0, 0.0, 0.0])
-        >>> L = eye(3, n=3, k=0)
-        >>> y = _rlagval(L, [1.0, 2.0, 3.0]) @ x
-        >>> z = np.polynomial.laguerre.lagval(x[0], [1.0, 2.0, 3.0])
-        >>> np.allclose(y[0], z)
-        True
-
-    .. seealso::
-        - `Wikipedia <https://en.wikipedia.org/wiki/Laguerre_polynomials>`_,
-        - `NumPy polynomial class <https://docs.scipy.org/doc//numpy-1.9.3/
-          reference/generated/numpy.polynomial.laguerre.lagval.html>`_.
-    """
-
-    if L.shape[0] != L.shape[1]:
-        raise Exception("Matrix representation of L is not square.")
-
-    c = np.asarray(c)
-
-    if c.ndim != 1:
-        raise Exception("coef must be a 1d array.")
-
-    D = c.shape[0]
-    if D == 0:
-        raise Exception("List of coefficients has zero size.")
-
-    def _matmat(L, x, c):
-        if x.ndim == 1:
-            is_1d = True
-            x = x.reshape(x.shape[0], 1)
-        else:
-            is_1d = False
-        batch_size = x.shape[1]
-        La0x = np.empty((L.shape[0], batch_size),
-                        dtype=binary_dtype(c.dtype, x.dtype))
-        La1x = np.empty((L.shape[0], batch_size),
-                        dtype=binary_dtype(c.dtype, x.dtype))
-        La2x = np.empty((L.shape[0], batch_size),
-                        dtype=binary_dtype(c.dtype, x.dtype))
-        np.copyto(La0x, x)
-        output = np.multiply(c[0], La0x)
-        if D > 1:
-            # loop over the coefficients
-            for i in range(1, D):
-                if i == 1:
-                    np.copyto(La1x, np.subtract(x, L @ x))
-                    if c[i] != 0.0:
-                        np.add(output, np.multiply(c[i], La1x), out=output)
-                else:
-                    np.copyto(La2x, np.divide(
-                        np.subtract(
-                            np.subtract(
-                                np.multiply(2.0 * (i - 1) + 1.0, La1x),
-                                L @ La1x),
-                            np.multiply(i - 1, La0x)), i))
-                    # Recurrence
-                    np.copyto(La0x, La1x)
-                    np.copyto(La1x, La2x)
-                    if c[i] != 0.0:
-                        np.add(output, np.multiply(c[i], La2x), out=output)
-        return output.ravel() if is_1d else output
-
-    return LazyLinOp(
-        shape=L.shape,
-        matmat=lambda x: _matmat(L, x, c),
-        rmatmat=lambda x: _matmat(L.T.conj(), x, c)
-    )
-
-
-def _rlegval(L, c):
-    r"""Constructs a :py:class:`.LazyLinOp` Legendre polynomial ``P(L)``
-    of linear operator ``L``.
-
-    ``P(L)`` is equal to :math:`c_0Id+c_1L_{e,1}(L)+\cdots+c_nL_{e,n}(L)`.
-
-    The k-th Legendre polynomial can be computed by recurrence:
-
-    .. math::
-
-        \begin{eqnarray}
-        L_{e,0}(L) &=& Id\\
-        L_{e,1}(L) &=& L\\
-        L_{e,k+1}(L) &=& \frac{(2k + 1)LL_{e,k}(L) - kL_{e,k-1}(L)}{k + 1}
-        \end{eqnarray}
-
-    ``Y = P(L) @ X`` shape is ``(L.shape[0], X.shape[1])``.
-
-
-    Args:
-        L: LazyLinOp
-            Linear operator (matrix representation must be square).
-        c: 1d array
-            List of Legendre polynomial(s) coefficients.
-            If the size of the 1d array is n + 1 then the largest power
-            of the polynomial is n.
-
-    Returns:
-        LazyLinOp
-
-    Raises:
-        Exception
-            Matrix representation of L is not square.
-        Exception
-            List of coefficients has zero size.
-        Exception
-            coef must be a 1d array.
-
-    Examples:
-        >>> import numpy as np
-        >>> from lazylinop import eye
-        >>> from lazylinop.wip.polynomial import _legval
-        >>> x = np.random.randn(3)
-        >>> L = eye(3, n=3, k=0)
-        >>> y = _legval(L, [1.0, 2.0, 3.0]) @ x
-        >>> z = np.polynomial.laguerre.legval(x[0], [1.0, 2.0, 3.0])
-        >>> np.allclose(y[0], z)
-        True
-
-    .. seealso::
-        - `Wikipedia <https://en.wikipedia.org/wiki/Legendre_polynomials>`_,
-        - `NumPy polynomial class <https://docs.scipy.org/doc//numpy-1.9.3/
-          reference/generated/numpy.polynomial.legendre.legval.html>`_.
-    """
-
-    if L.shape[0] != L.shape[1]:
-        raise Exception("Matrix representation of L is not square.")
-
-    c = np.asarray(c)
-
-    if c.ndim != 1:
-        raise Exception("coef must be a 1d array.")
-
-    D = c.shape[0]
-    if D == 0:
-        raise Exception("List of coefficients has zero size.")
-
-    def _matmat(L, x, c):
-        if x.ndim == 1:
-            is_1d = True
-            x = x.reshape(x.shape[0], 1)
-        else:
-            is_1d = False
-        batch_size = x.shape[1]
-        Le0x = np.empty((L.shape[0], batch_size),
-                        dtype=binary_dtype(c.dtype, x.dtype))
-        Le1x = np.empty((L.shape[0], batch_size),
-                        dtype=binary_dtype(c.dtype, x.dtype))
-        Le2x = np.empty((L.shape[0], batch_size),
-                        dtype=binary_dtype(c.dtype, x.dtype))
-        np.copyto(Le0x, x)
-        output = np.multiply(c[0], Le0x)
-        if D > 1:
-            # loop over the coefficients
-            for i in range(1, D):
-                if i == 1:
-                    np.copyto(Le1x, L @ x)
-                    if c[i] != 0.0:
-                        np.add(output, np.multiply(c[i], Le1x), out=output)
-                else:
-                    np.copyto(Le2x, np.divide(
-                        np.subtract(
-                            np.multiply(2.0 * (i - 1) + 1.0, L @ Le1x),
-                            np.multiply(i - 1, Le0x)), i))
-                    # Recurrence
-                    np.copyto(Le0x, Le1x)
-                    np.copyto(Le1x, Le2x)
-                    if c[i] != 0.0:
-                        np.add(output, np.multiply(c[i], Le2x), out=output)
-        return output.ravel() if is_1d else output
-
-    return LazyLinOp(
-        shape=L.shape,
-        matmat=lambda x: _matmat(L, x, c),
-        rmatmat=lambda x: _matmat(L.T.conj(), x, c)
-    )
-
-
 def power(L, n):
     r"""Constructs the n-th power :math:`L^n` of linear operator :math:`L`.
     Matrix representation of :math:`L` must be square.
     :octicon:`alert-fill;1em;sd-text-danger` In some cases
     :code:`power(L,n) @ x` can be least efficient than
     :code:`M=np.power(L.toarray()) @ x`.
 
@@ -1949,28 +1451,28 @@
         ValueError
             n must be > 0.
         Exception
             Matrix representation of L is not square.
 
     Examples:
         >>> import numpy as np
-        >>> from lazylinop import eye
-        >>> from lazylinop.wip.polynomial import power
-        >>> L = power(eye(3, n=3, k=0), 3)
+        >>> import lazylinop as lz
+        >>> L = lz.polynomial.power(lz.eye(3, n=3, k=0), 3)
         >>> x = np.full(3, 1.0)
         >>> np.allclose(L @ x, x)
         True
-        >>> L = power(eye(3, n=3, k=1), 3)
+        >>> L = lz.polynomial.power(lz.eye(3, n=3, k=1), 3)
         >>> # Note that L is in fact zero (nilpotent matrix)
         >>> x = np.full(3, 1.0)
         >>> np.allclose(L @ x, np.zeros(3, dtype=np.float_))
         True
 
     .. seealso::
         `NumPy power function
         <https://numpy.org/doc/stable/reference/generated/numpy.power.html>`_.
     """
     return aslazylinop(L)**n
 
+
 # if __name__ == '__main__':
 #     import doctest
 #     doctest.testmod()
```

## Comparing `lazylinop-1.7.1.dist-info/LICENSE.txt` & `lazylinop-1.8.0.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `lazylinop-1.7.1.dist-info/METADATA` & `lazylinop-1.8.0.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: lazylinop
-Version: 1.7.1
+Version: 1.8.0
 Summary: A package dedicated to lazy linear operators based on diverse backends/libraries.
 Author-email: Inria <remi.gribonval@inria.fr>, Pascal Carrivain <pascal.carrivain@inria.fr>, Simon Delamare <simon.delamare@ens-lyon.fr>, Hakim Hadj-Djilani <hakim.hadj-djilani@inria.fr>, Rémi Gribonval <remi.gribonval@inria.fr>
 License: Copyright 2023, Inria
         
         BSD License 2.0
         
         Redistribution and use in source and binary forms, with or without
```

## Comparing `lazylinop-1.7.1.dist-info/RECORD` & `lazylinop-1.8.0.dist-info/RECORD`

 * *Files 10% similar despite different names*

```diff
@@ -1,45 +1,47 @@
-lazylinop/__init__.py,sha256=cGWnxKxkjmYA20xpc9Xm_sypeVWt7laA_ID0sNhLong,126
+lazylinop/__init__.py,sha256=ClaZUz2Uu4FPDlj62KGZnhzvwkrD-1LvJxevFQmucso,152
 lazylinop/check_op.py,sha256=F9Fruv6a-_izX9E-RqgY369FsSUPJBzNexfa1eCc310,8275
 lazylinop/lazylinop.py,sha256=eSU6DDPTItVR8WyqrVt3OKgyB2qk-JzMKXQ69VEJQH4,52187
 lazylinop/basicops/__init__.py,sha256=_LNJ-J7w_qkGvBs0OgSWJl5mYwcgBIVc6E5qf4fp2YU,370
 lazylinop/basicops/add.py,sha256=PVftHIYd4l5Ddhr_kSoZCzcpPza14ylL0u4-62gYW3M,1508
 lazylinop/basicops/blockdiag.py,sha256=Ka2zsHzFNSoyDQC3VVMVsL_xHriY4QWg53Bf6zZeSKw,2255
 lazylinop/basicops/cat.py,sha256=8anT601uU8owwDD1LrxNN4mEVyBzSRqLdY_5IgBns_I,1852
 lazylinop/basicops/diag.py,sha256=I3Ai0tT5SFfM9mg33oirV4P5LeNgBN3eAawn6kH6rNE,11699
 lazylinop/basicops/eye.py,sha256=lWppYxMOhXUxKHUL3oS086GTXW2Zqn87GRESzwEy7ec,3406
 lazylinop/basicops/kron.py,sha256=Tz9tFkXqZ95F4IWdMIlVrN-vVuIi3mkf4A2TjfBuunQ,3792
 lazylinop/basicops/ones.py,sha256=W3cH6TY4uyc0ZORGut9xfWJY924WSFkZJX-TIKb5mTg,2309
 lazylinop/basicops/pad.py,sha256=ryon701dqmAntpa8nyHT8DsYqhsnv6NV3vzj2U1oDbo,31288
 lazylinop/basicops/zeros.py,sha256=tLcN6ohWz51r5iwVtWYFDWCambR0txymC_18og9-B9s,1573
+lazylinop/polynomial/__init__.py,sha256=dGdRlm9i4HmqWcFIHAYV4MueUfQ1KNIsuuKadGa4-q0,264
+lazylinop/polynomial/polynomial.py,sha256=iCf5AmHZJ4PNwFYKjQdaqQlwcfpZDkYhJhbFpXdlpdY,53006
 lazylinop/wip/__init__.py,sha256=ww8T00bJlNfAZtvPfJOCIqfNmsg9PomHmWyhu2kB3QM,78
 lazylinop/wip/code_optimization.py,sha256=ieJcsn0RFt8E3FBwv6zH2bddRkEDiupp0nsnYDLr__U,1443
 lazylinop/wip/linear_algebra.py,sha256=KuUz7eyOxNn3PlymsQ_h5l1qCmLUfbSoCI5ZbwIFYfw,1447
-lazylinop/wip/polynomial.py,sha256=YZ0KTdHaspNw1fuvjNsFjgWtfLGlAXF-nEqAJjE8TQA,68835
 lazylinop/wip/signal.py,sha256=0hIj2rb5xJ85ehZ-y4xcr3MumYJBsaEum-QV38SG6Fo,133585
 lazylinop/wip/special_matrices.py,sha256=bU0UPHN4VbvpKEes7FQSJi5FnBPpzMlyQxKmt6nNWi0,57938
 lazylinop/wip/basicops/__init__.py,sha256=fS9lwF0O9tkBlk7OXo6VBohfMO6nWjMHGDwVhMHulVs,52
 lazylinop/wip/basicops/average.py,sha256=LD02eUm-mN3mdfrgBtxlK1RjkBZuAMnapuilK30p6VE,1607
 lazylinop/wip/basicops/mean.py,sha256=rFu4lng_7P8duw2oSnoNZDKmEHEfrLPtnbmcUKs7SDQ,573
 lazylinop/wip/linalg/__init__.py,sha256=tT37IW-J-jlBQzHhIWeCZLyqypFOra8B7t3Tlz3fCTA,298
 lazylinop/wip/linalg/coshm.py,sha256=81UlRLwlaeYT6vjIQjsG41MRHp56P8GuDaHWrdgYtAY,4792
-lazylinop/wip/linalg/cosm.py,sha256=MWsI6i8ks4VHSXbBE5Jl4DXZm7kMfVKv-BelOF0CKtU,2820
-lazylinop/wip/linalg/expm.py,sha256=KZph2urO9i6eGfsMgv8WS4jdmn2DutN2khiG8sRUTOc,4237
+lazylinop/wip/linalg/cosm.py,sha256=LGLKc1VGIX2J7BuL4AFJVoKpcglcAl3Aqvdmgy4wSJ0,2816
+lazylinop/wip/linalg/expm.py,sha256=ivEsbaAkqBHH6qulGwrbEZBB7ONJLDCLWIRHH7O9gWc,4233
 lazylinop/wip/linalg/khatri_rao.py,sha256=ob4rPDzX2WU4DTZz-02mdcJaaQTBwpS3Koldaxofozw,5587
 lazylinop/wip/linalg/logm.py,sha256=JJDAiqOeWN7fBY_6Ju04Qn1tIN0hLqKVpG4luWKP3bM,4667
 lazylinop/wip/linalg/sinhm.py,sha256=qdr8snq2n5AzbOpHhThHFbjivdZXCp34oBrR1p9dxFc,4694
-lazylinop/wip/linalg/sinm.py,sha256=zMPBAHomz4YFWIA2ZWDyWQWvV82ermLiYJ_hUqned-c,2827
+lazylinop/wip/linalg/sinm.py,sha256=QYt4VggWD-k4D7eZtg6F3cxMCBJrMn2aymyzTMXnUrI,2823
 lazylinop/wip/linalg/spectral_norm.py,sha256=oJi89eZA3yzzeIpE5f1AyDmvkQ2QXLC-G3Lw7oOoHfQ,1582
 lazylinop/wip/linalg/sqrtm.py,sha256=NCC-rQdNwOScIawgTYGHiRPRTA54O2t1sBZ6i2rRXiI,3754
 lazylinop/wip/parallel/__init__.py,sha256=iuAy8qIWtIv67Ro5GkkFUUaJUyJOuYXhkCaF0k8fFAo,253
 lazylinop/wip/parallel/mpilop.py,sha256=zJQXwVoQIOiL1bHbg_wNgqMKq4DH45LVayRxq-wp-rA,8328
 lazylinop/wip/parallel/pmatmat.py,sha256=2stXEbqFsj984Eg47EPbMtAutQFb9shSTtJHVQPefKw,4897
 lazylinop/wip/parallel/pmatmat_mpi.py,sha256=9s6o8dfWQitLlZSa5MVdkzke6JM7606d_i88a7aVMGo,4250
 lazylinop/wip/parallel/pmatmat_process.py,sha256=pTUXpSB0vq4KGNepKH3uQkmN8fkF6KFEuTWcLUwt-p0,5902
 lazylinop/wip/parallel/pmatmat_thread.py,sha256=gzjIoNV-ePz30K0l_TipJi--VyVfO3vl0E8oOn9OH5o,3306
 lazylinop/wip/random/__init__.py,sha256=Sqc6D6d_4UI8LQTlBzRz5IDpSLVK5ejcL5FJmC_A2FI,23
 lazylinop/wip/random/rand.py,sha256=8ZEtNxJtInOsJxcYDj8JdTobNzLXlaEmCDAlqbMq_mo,6721
-lazylinop-1.7.1.dist-info/LICENSE.txt,sha256=jHt8qQXwxwsxIgSCZbFwPqQw3R1QWQK0JzZZ3PAwlU0,1434
-lazylinop-1.7.1.dist-info/METADATA,sha256=qVZYZrXOc_wpvfARwin_TpZEfdk5g4wer9PYuV91RS4,8177
-lazylinop-1.7.1.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-lazylinop-1.7.1.dist-info/top_level.txt,sha256=zq6N2WH1Vl_0zSzqC12W0Oil87_uMjD3sYhWGjRioIc,10
-lazylinop-1.7.1.dist-info/RECORD,,
+lazylinop/wip/signal/slices.py,sha256=nAeDcXj0HlYHt5U220uyjDl8b6vXUVHs8tRv-NTMgjw,9453
+lazylinop-1.8.0.dist-info/LICENSE.txt,sha256=jHt8qQXwxwsxIgSCZbFwPqQw3R1QWQK0JzZZ3PAwlU0,1434
+lazylinop-1.8.0.dist-info/METADATA,sha256=46B6Yf-avGsWVXIlLKq4QShZppPGGoGFkOSsVlmCHko,8177
+lazylinop-1.8.0.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+lazylinop-1.8.0.dist-info/top_level.txt,sha256=zq6N2WH1Vl_0zSzqC12W0Oil87_uMjD3sYhWGjRioIc,10
+lazylinop-1.8.0.dist-info/RECORD,,
```

